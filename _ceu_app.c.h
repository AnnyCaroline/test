/*
* This file is automatically generated.
* http://www.ceu-lang.org/
* http://github.com/ceu-lang/ceu/
*
* CÃ©u is distributed under the MIT License:
*

Copyright (C) 2012-2016 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



/* ENV_HEADER */

#include <stdint.h>

typedef void none;

#ifndef __cplusplus
typedef unsigned char bool;
#endif
typedef unsigned char byte;
typedef unsigned int  uint;

//typedef ssize_t  ssize;       // no support in Arduino
typedef size_t   usize;

typedef int8_t    s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

typedef uint8_t   u8;
#ifndef __AVR
typedef uint16_t u16;         // already defined in "USBAPI.h"
#endif
typedef uint32_t u32;
typedef uint64_t u64;

typedef float    real;
typedef float    r32;
typedef double   r64;


/* ENV_CEU */



/* CEU_C */

#define CEU_FEATURES_ISR static
#define CEU_FEATURES_ISR_STATIC
#undef CEU_FEATURES_ASYNC
#undef CEU_FEATURES_TRACE
#undef CEU_FEATURES_DYNAMIC
#undef CEU_FEATURES_LUA
#undef CEU_FEATURES_THREAD
#undef CEU_FEATURES_POOL
#undef CEU_FEATURES_EXCEPTION
#undef CEU_FEATURES_PAUSE
#undef CEU_FEATURES_OS
        /* CEU_FEATURES */

#include <stddef.h>     /* offsetof */
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memset, strlen */
#ifdef CEU_TESTS
#include <stdio.h>
#endif

#ifdef CEU_FEATURES_LUA
#include <lua5.3/lua.h>
#include <lua5.3/lauxlib.h>
#include <lua5.3/lualib.h>
#endif

#define S8_MIN   -127
#define S8_MAX    127
#define U8_MAX    255

#define S16_MIN  -32767
#define S16_MAX   32767
#define U16_MAX   65535

#define S32_MIN  -2147483647
#define S32_MAX   2147483647
#define U32_MAX   4294967295

#define S64_MIN  -9223372036854775807
#define S64_MAX   9223372036854775807
#define U64_MAX   18446744073709551615

typedef u16 tceu_nevt;   /* TODO */
typedef u8  tceu_nstk;   /* TODO */
typedef u8 tceu_ntrl;
typedef u16 tceu_nlbl;

#define CEU_TRAILS_N 9
#ifndef CEU_STACK_N
#define CEU_STACK_N 500
#endif

#define CEU_API
CEU_API void ceu_start (int argc, char* argv[]);
CEU_API void ceu_stop  (void);
CEU_API void ceu_input (tceu_nevt id, void* params);
CEU_API int  ceu_loop  (int argc, char* argv[]);

#ifdef CEU_FEATURES_TRACE
#define CEU_TRACE_null   ((tceu_trace){NULL,NULL,0})

typedef struct tceu_trace {
    struct tceu_trace* up;
    const char* file;
    u32 line;
} tceu_trace;
#endif

struct tceu_code_mem;
struct tceu_pool_pak;

typedef struct tceu_evt {
    tceu_nevt id;
    union {
        void* mem;                   /* CEU_INPUT__PROPAGATE_CODE, CEU_EVENT__MIN */
#ifdef CEU_FEATURES_POOL
        struct tceu_pool_pak* pak;   /* CEU_INPUT__PROPAGATE_POOL */
#endif
    };
} tceu_evt;

typedef struct tceu_range {
    struct tceu_code_mem* mem;
    tceu_ntrl             trl0;
    tceu_ntrl             trlF;
} tceu_range;

typedef struct tceu_stk {
    tceu_evt   evt;
    tceu_range range;
    void*      params;
    usize      params_n;
    bool       is_alive;
    struct tceu_stk* prv;
} tceu_stk;

struct tceu_data_Exception;

typedef struct tceu_trl {
    struct {
        tceu_evt evt;
        union {
            struct {
                tceu_nlbl lbl;
                tceu_nstk level;       /* CEU_INPUT__STACKED */
            };
#ifdef CEU_FEATURES_PAUSE
            struct {
                tceu_evt  pse_evt;
                tceu_ntrl pse_skip;
                u8        pse_paused;
            };
#endif
        };
    };
} tceu_trl;

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_catch {
    struct tceu_catch*         up;
    struct tceu_code_mem*      mem;
    tceu_ntrl                  trl;
    struct tceu_opt_Exception* exception;
} tceu_catch;
#endif

typedef struct tceu_code_mem {
#ifdef CEU_FEATURES_POOL
    struct tceu_pool_pak* pak;
#endif
    struct tceu_code_mem* up_mem;
    u8          depth;
#ifdef CEU_FEATURES_TRACE
    tceu_trace  trace;
#endif
#ifdef CEU_FEATURES_EXCEPTION
    tceu_catch* catches;
#endif
#ifdef CEU_FEATURES_LUA
    lua_State*  lua;
#endif
    bool has_term;
    tceu_ntrl   trails_n;
    tceu_trl    _trails[0];
} tceu_code_mem;

#ifdef CEU_FEATURES_THREAD
typedef struct tceu_threads_data {
    CEU_THREADS_T id;
    u8 has_started:    1;
    u8 has_terminated: 1;
    u8 has_aborted:    1;
    u8 has_notified:   1;
    struct tceu_threads_data* nxt;
} tceu_threads_data;

typedef struct {
    tceu_code_mem*     mem;
    tceu_threads_data* thread;
} tceu_threads_param;
#endif

#ifdef CEU_FEATURES_ISR_STATIC
typedef struct tceu_isr_evt {
    tceu_nevt id;
    u8        len;
    void*     args;
} tceu_isr_evt;
#else
typedef struct tceu_evt_id_params {
    tceu_nevt id;
    void*     params;
} tceu_evt_id_params;
typedef struct tceu_isr {
    void (*fun)(tceu_code_mem*);
    tceu_code_mem*     mem;
    tceu_evt_id_params evt;
} tceu_isr;
#endif

/*****************************************************************************/

/* CEU_VECTOR_H */
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memcpy */

typedef struct {
    usize max;
    usize len;
    usize ini;
    usize unit;
    u8    is_ring:    1;
    u8    is_dyn:     1;
    u8    is_freezed: 1;
    byte* buf;
} tceu_vector;

#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))

#define ceu_vector_idx(vec,idx)     ((vec)->is_ring ? (((vec)->ini + (idx)) % (vec)->max) : (idx))
#define ceu_vector_buf_get(vec,idx) (&(vec)->buf[ceu_vector_idx(vec,idx)*(vec)->unit])
#define ceu_vector_ptr(vec)         (vec)

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu,CEU_TRACE(0))
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n,CEU_TRACE(0))
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,CEU_TRACE(0))
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow,CEU_TRACE(0))
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,CEU_TRACE(0))
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b,CEU_TRACE(0))
#else
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu)
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n)
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,_)
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow)
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,_)
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b)
#endif

void  ceu_vector_init            (tceu_vector* vector, usize max, bool is_ring, bool is_dyn, usize unit, byte* buf);

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c,d)
#else
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c)
#endif

#ifdef CEU_FEATURES_DYNAMIC
byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );
#endif

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c,d)
#else
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c)
#endif

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );


/* CEU_NATIVE_PRE */

#define CEU_ISR(id) ISR(id)

#define CEU_PM_IMPL

    enum {
        CEU_PM_ADC = 0,
        CEU_PM_SPI,
        CEU_PM_TIMER0,
        CEU_PM_TIMER1,
        CEU_PM_TIMER2, // TODO: works in ADC, power-save, ext-standby





        CEU_PM_USART,
        CEU_PM_TWI = 0,
        CEU_PM_N,
    };

# 1 "./libraries/driver-pm/avr/../pm.c" 1




static u32 ceu_pm_state = 0; // TODO: max 32 devices

void ceu_pm_init (void);

void ceu_pm_sleep (void);

int ceu_pm_get (int dev) {
    return bitRead(ceu_pm_state, dev);
}

void ceu_pm_set (u8 dev, bool v) {
    if (v) {
        bitSet(ceu_pm_state, dev);
    } else {
        bitClear(ceu_pm_state, dev);
    }
}
# 22 "./libraries/driver-pm/avr/pm.ceu" 2
#include "LowPower.h"
#include "LowPower.cpp"

    void ceu_pm_init (void) {
    }

    void ceu_pm_sleep (void)
    {
# 45 "./libraries/driver-pm/avr/pm.ceu"
        if (ceu_pm_get(CEU_PM_TIMER0) || ceu_pm_get(CEU_PM_TIMER1) ||
            ceu_pm_get(CEU_PM_TIMER2) || ceu_pm_get(CEU_PM_USART) ||
            ceu_pm_get(CEU_PM_TWI) || ceu_pm_get(CEU_PM_SPI))
        {

            LowPower.idle(SLEEP_FOREVER,
                          (adc_t) ceu_pm_get(CEU_PM_ADC),





                          (timer2_t) ceu_pm_get(CEU_PM_TIMER2),
                          (timer1_t) ceu_pm_get(CEU_PM_TIMER1),
                          (timer0_t) ceu_pm_get(CEU_PM_TIMER0),
                          (spi_t) ceu_pm_get(CEU_PM_SPI),



                          (usart0_t) ceu_pm_get(CEU_PM_USART),
                          (twi_t) ceu_pm_get(CEU_PM_TWI));
        }
        else if (ceu_pm_get(CEU_PM_ADC))
        {
            LowPower.adcNoiseReduction(SLEEP_FOREVER,
                                       (adc_t) ceu_pm_get(CEU_PM_ADC),
                                       TIMER2_OFF);
        }
        else
        {
            LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);
        }


    }

#define __WCLOCK_CEU__
    void ceu_wclock_init (void);
    //void ceu_wclock         (bool v);      // TODO: ???
    void ceu_wclock_request (s32 us, bool was_active);
    void ceu_wclock_done (void);
    s32 ceu_wclock_dt (void);
    u32 ceu_wclock_now (void);

#define USART_BAUD(bps) ((F_CPU/4/bps - 1) / 2)

#include <stdio.h>
    typedef struct sockaddr sockaddr;
    typedef struct sockaddr_in sockaddr_in;
    typedef struct sockaddr_storage sockaddr_storage;

#include <string.h>

    /* A utility function to reverse a string  */
    void reverse(char str[], int length)
    {
        int start = 0;
        int end_ = length -1;
        while (start < end_)
        {
            char tmp = *(str+start);
            *(str+start) = *(str+end_);
            *(str+end_) = tmp;
            start++;
            end_--;
        }
    }

    // Implementation of itoa()
    usize ceu_itona(int num, char* str, int base, usize max)
    {
        usize i = 0;
        bool isNegative = 0;

        /* Handle 0 explicitely, otherwise empty string is printed for 0 */
        if (num == 0) {
            if (i >= max) return 0;
            str[i++] = '0';
            if (i >= max) return 0;
            str[i] = '\0';
            return i+1;
        }

        // In standard itoa(), negative numbers are handled only with 
        // base 10. Otherwise numbers are considered unsigned.
        if (num < 0 && base == 10) {
            isNegative = 1;
            num = -num;
        }

        // Process individual digits
        while (num != 0) {
            int rem = num % base;
            if (i >= max) return 0;
            str[i++] = (rem > 9)? (rem-10) + 'A' : rem + '0';
            num = num/base;
        }

        // If number is negative, append '-'
        if (isNegative) {
            if (i >= max) return 0;
            str[i++] = '-';
        }

        if (i >= max) return 0;
        str[i] = '\0'; // Append string terminator

        // Reverse the string
        reverse(str, i);

        return i+1;
    }


/* EVENTS_ENUM */

enum {
    /* non-emitable */
    CEU_INPUT__NONE = 0,
    CEU_INPUT__STACKED,
    CEU_INPUT__FINALIZE,
    CEU_INPUT__THROW,
    CEU_INPUT__PAUSE_BLOCK,
    CEU_INPUT__PROPAGATE_CODE,
    CEU_INPUT__PROPAGATE_POOL,

    /* emitable */
    CEU_INPUT__CLEAR,           /* 7 */
    CEU_INPUT__PAUSE,
    CEU_INPUT__RESUME,
    CEU_INPUT__CODE_TERMINATED,
CEU_INPUT__PRIM,
    CEU_INPUT__ASYNC,
    CEU_INPUT__THREAD,
    CEU_INPUT__WCLOCK,

//CEU_INPUT__MIN,
    CEU_INPUT_CEU_WCLOCK,
CEU_INPUT_USART_RX,
CEU_INPUT_INT0,

//CEU_INPUT__MAX,

CEU_EVENT__MIN,
    CEU_EVENT_LOCK_OK_UNLOCKED,
CEU_EVENT_CHANGE_283,

};

enum {
    CEU_OUTPUT__NONE = 0,
    CEU_OUTPUT_OUT,
CEU_OUTPUT_OUT_13,

};

/* CEU_MAIN */


#if 0
#define ceu_callback_log_num(a,b)
#define ceu_callback_log_str(a,b)
#define ceu_callback_log_flush(a)
#define ceu_callback_wclock_min(a,b)
#define ceu_callback_abort(a,b)
#define ceu_callback_terminating(a)
#define ceu_callback_wclock_dt(a) CEU_WCLOCK_INACTIVE
#define ceu_callback_start(a)
#define ceu_callback_stop(a)
#define ceu_callback_step(a)
#define ceu_callback_realloc(a,b,c) NULL
#define ceu_callback_free(a,b)
#endif

//#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"

#ifdef ceu_assert_ex
#define ceu_assert(a,b) ceu_assert_ex(a,b,NONE)
#else
#ifdef CEU_FEATURES_TRACE
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_trace(trace, msg);                                      \
        ceu_callback_abort(0, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg), CEU_TRACE(0))
#else
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_callback_abort(0, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg),NONE)
#endif
#endif

#ifndef ceu_assert_sys
#define ceu_assert_sys(v,msg)   \
    if (!(v)) {                 \
        ceu_callback_log_str(msg, CEU_TRACE_null);  \
        ceu_callback_abort(0, CEU_TRACE_null);      \
    }
#endif

#ifdef CEU_FEATURES_TRACE
static void ceu_trace (tceu_trace trace, const char* msg) {
    static bool IS_FIRST = 1;
    bool is_first = IS_FIRST;

    IS_FIRST = 0;

    if (trace.up != NULL) {
        ceu_trace(*trace.up, msg);
    }

    if (is_first) {
        IS_FIRST = 1;
        ceu_callback_log_str("\n", CEU_TRACE_null);
    }

    ceu_callback_log_str("[",        CEU_TRACE_null);
    ceu_callback_log_str(trace.file, CEU_TRACE_null);
    ceu_callback_log_str(":",        CEU_TRACE_null);
    ceu_callback_log_num(trace.line, CEU_TRACE_null);
    ceu_callback_log_str("]",        CEU_TRACE_null);
    ceu_callback_log_str(" -> ",     CEU_TRACE_null);

    if (is_first) {
        ceu_callback_log_str("runtime error: ", CEU_TRACE_null);
        ceu_callback_log_str(msg,               CEU_TRACE_null);
        ceu_callback_log_str("\n",              CEU_TRACE_null);
        ceu_callback_log_flush(CEU_TRACE_null);
    }
}
#else
#define ceu_trace(a,b)
#endif

#define CEU_ISRS_N 4

/* CEU_ISRS_DEFINES */
#define CEU_ISR__TIMER1_COMPA_vect
#define CEU_ISR__USART_RX_vect
#define CEU_ISR__INT0_vect


/* EVENTS_DEFINES */
#define _CEU_INPUT_CEU_WCLOCK_
#define _CEU_OUTPUT_OUT_
#define _CEU_INPUT_USART_RX_
#define _CEU_INPUT_INT0_
#define _CEU_OUTPUT_OUT_13_


/* CEU_DATAS_HIERS */
typedef s16 tceu_ndata;  /* TODO */
enum {
        CEU_DATA_Exception = 0,
};

tceu_ndata CEU_DATA_SUPERS_Exception [] = {
        0,
};
tceu_ndata CEU_DATA_NUMS_Exception [] = {
        CEU_DATA_Exception,
};


static int ceu_data_is (tceu_ndata* supers, tceu_ndata me, tceu_ndata cmp) {
    return (me==cmp || (me!=0 && ceu_data_is(supers,supers[me],cmp)));
}

#ifdef CEU_FEATURES_TRACE
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c,d)
#else
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c)
#endif

__attribute__((__unused__))
static void* ceu_data_as_ (tceu_ndata* supers, tceu_ndata* me, tceu_ndata cmp
#ifdef CEU_FEATURES_TRACE
                         , tceu_trace trace
#endif
                         )
{
    ceu_assert_ex(ceu_data_is(supers, *me, cmp), "invalid cast `as`", trace);
    return me;
}

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a,b)
#else
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a)
#endif

__attribute__((__unused__))
static tceu_evt* CEU_OPTION_EVT_ (tceu_evt* alias
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(alias != NULL, "value is not set", trace);
    return alias;
}

/* CEU_VECTOR_C */
void ceu_vector_init (tceu_vector* vector, usize max, bool is_ring,
                      bool is_dyn, usize unit, byte* buf) {
    vector->len        = 0;
    vector->max        = max;
    vector->ini        = 0;
    vector->unit       = unit;
    vector->is_dyn     = is_dyn;
    vector->is_ring    = is_ring;
    vector->is_freezed = 0;
    vector->buf        = buf;
}

#ifdef CEU_FEATURES_DYNAMIC
byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(vector->is_dyn, "static vector", trace);

    if (vector->max == len) {
        goto END;
    }

    if (len == 0) {
        /* free */
        if (vector->buf != NULL) {
            vector->max = 0;
            ceu_callback_free(vector->buf, trace);
            vector->buf = NULL;
        }
    } else {
        ceu_assert_ex(len > vector->max, "not implemented: shrinking vectors", trace);
        vector->buf = (byte*) ceu_callback_realloc(vector->buf, len*vector->unit, trace);

        if (vector->is_ring && vector->ini>0) {
            /*
             * [X,Y,Z,I,J,K,L,#####,A,B]       -> (grow) ->
             * [X,Y,Z,I,J,K,L,#####,A,B,-,-,-] -> (1st memcpy) ->
             * [?,?,?,I,J,K,L,#####,A,B,X,Y,Z] -> (2nd memmove) ->
             * [I,J,K,L,#####,-,-,-,A,B,X,Y,Z]
             */
            usize dif = len - vector->max;
            usize rig = vector->max - vector->ini;
            if (vector->len > rig) { // if wrap-around then need to shuffle
                usize num = vector->len - rig;
                memcpy(&vector->buf[vector->max * vector->unit], // -,-,-
                       &vector->buf[0],                          // X,Y,Z
                       (num > dif ? dif : num)  * vector->unit); // 3
                if (num > dif) {
                    memmove(&vector->buf[0],                     // X,Y,Z
                            &vector->buf[dif * vector->unit],    // I,J,K,L
                            (num - dif)      * vector->unit);    // rest
                }
            }
        }

        vector->max = len;
    }

    if (freeze) {
        vector->is_freezed = 1;
    }

END:
    return vector->buf;
}
#endif

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        if (len > vector->len) {
            return 0;
        }
    }

    /* fixed size */
#ifdef CEU_FEATURES_DYNAMIC
    if (!vector->is_dyn || vector->is_freezed)
#endif
    {
        if (len > vector->max) {
            return 0;
        }

    /* variable size */
    }
#ifdef CEU_FEATURES_DYNAMIC
    else
    {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                if (len != 0) {
                    return 0;
                }
            }
        }
    }
#endif

    return 1;
}

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        ceu_assert_ex(len <= vector->len, "access out of bounds", trace);
    }

    /* fixed size */
#ifdef CEU_FEATURES_DYNAMIC
    if (!vector->is_dyn || vector->is_freezed)
#endif
    {
        ceu_assert_ex(len <= vector->max, "access out of bounds", trace);

    /* variable size */
    }
#ifdef CEU_FEATURES_DYNAMIC
    else
    {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
/* TODO: shrink memory */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                ceu_assert_ex(len==0, "access out of bounds", trace);
            }
        }
    }
#endif

    if (vector->is_ring && len<vector->len) {
        vector->ini = (vector->ini + (vector->len - len)) % vector->max;
    }

    vector->len = len;
}

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(idx < vector->len, "access out of bounds", trace);
    return ceu_vector_buf_get(vector, idx);
}

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize n = ((nu % vector->unit) == 0) ? nu/vector->unit : nu/vector->unit+1;
#if 0
    if (vector->len < idx+n) {
        char err[50];
        snprintf(err,50, "access out of bounds : length=%ld, index=%ld", vector->len, idx+n);
        ceu_assert_ex(0, err, file, line);
    }
#else
    ceu_assert_ex((vector->len >= idx+n), "access out of bounds", trace);
#endif

    usize k  = (vector->max - ceu_vector_idx(vector,idx));
    usize ku = k * vector->unit;

    if (vector->is_ring && ku<nu) {
        memcpy(ceu_vector_buf_get(vector,idx),   buf,    ku);
        memcpy(ceu_vector_buf_get(vector,idx+k), buf+ku, nu-ku);
    } else {
        memcpy(ceu_vector_buf_get(vector,idx), buf, nu);
    }
}

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize unit = dst->unit;
    ceu_assert_ex((src->unit == dst->unit), "incompatible vectors", trace);

    ceu_assert_ex((src->len >= src_i+n), "access out of bounds", trace);
    ceu_vector_setlen_ex(dst, MAX(dst->len,dst_i+n), 1, trace);

    usize dif_src = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
    usize dif_dst = MIN(n, (dst->max - ceu_vector_idx(dst,dst_i)));
    usize dif = MIN(dif_src, dif_dst);

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);

    dst_i += dif;
    src_i += dif;
    n -= dif;

    if (n == 0) {
        return;
    }

    if (dif_src > dif_dst) {
        dif = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    } else if (dif_dst > dif_src) {
        dif = MIN(n, (dst->max - ceu_vector_idx(dst,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    }

    if (n == 0) {
        return;
    }

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), n);
}


#ifdef CEU_FEATURES_POOL

/* CEU_POOL_C */
#include <stdlib.h>     /* NULL */

typedef struct {
    usize   len;
    usize   free;
    usize   index;
    usize   unit;
    byte*   buf;
    byte**  queue; /* NULL on dynamic pools */
} tceu_pool;

void ceu_pool_init (tceu_pool* pool, usize len, usize unit, byte** queue, byte* buf)
{
    usize i;
    pool->len   = len;
    pool->free  = len;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->buf   = buf;
    for (i=0; i<len; i++) {
        queue[i] = &buf[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->len) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    usize empty = pool->index + pool->free;
    if (empty >= pool->len) {
        empty -= pool->len;
    }
    pool->queue[empty] = val;
    pool->free++;
}


typedef struct tceu_code_mem_dyn {
    struct tceu_code_mem_dyn* prv;
    struct tceu_code_mem_dyn* nxt;
    u8 is_alive: 1;
    tceu_code_mem mem[0];   /* actual tceu_code_mem is in sequence */
} tceu_code_mem_dyn;

typedef struct tceu_pool_pak {
    tceu_pool         pool;
    tceu_code_mem_dyn first;
    tceu_code_mem*    up_mem;
    u8                n_traversing;
} tceu_pool_pak;

#endif

/* CEU_DATAS_MEMS */

#pragma pack(push,1)
typedef struct tceu_data_Lock {
    #line 1 "libraries/driver-gpio/examples/out-01.ceu"
bool  is_locked;
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
} tceu_data_Lock;

typedef struct tceu_data_Exception {
    tceu_ndata _enum;
    #line 1 "libraries/driver-gpio/examples/out-01.ceu"
char*  message;
} tceu_data_Exception;

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_tceu_opt_usize(a,b) CEU_OPTION_tceu_opt_usize_(a,b)
#else
#define CEU_OPTION_tceu_opt_usize(a,b) CEU_OPTION_tceu_opt_usize_(a)
#endif
typedef struct tceu_opt_usize {
    bool      is_set;
    usize value;
} tceu_opt_usize;

static tceu_opt_usize* CEU_OPTION_tceu_opt_usize_ (tceu_opt_usize* opt
#ifdef CEU_FEATURES_TRACE
                                              , tceu_trace trace
#endif
                                              ) {
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}
#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_tceu_opt_int(a,b) CEU_OPTION_tceu_opt_int_(a,b)
#else
#define CEU_OPTION_tceu_opt_int(a,b) CEU_OPTION_tceu_opt_int_(a)
#endif
typedef struct tceu_opt_int {
    bool      is_set;
    int value;
} tceu_opt_int;

static tceu_opt_int* CEU_OPTION_tceu_opt_int_ (tceu_opt_int* opt
#ifdef CEU_FEATURES_TRACE
                                              , tceu_trace trace
#endif
                                              ) {
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}


#pragma pack(pop)

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_opt_Exception {
    bool      is_set;
    tceu_data_Exception value;
} tceu_opt_Exception;

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a,b)
#else
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a)
#endif

static tceu_opt_Exception* CEU_OPTION_tceu_opt_Exception_ (tceu_opt_Exception* opt
#ifdef CEU_FEATURES_TRACE
                                                          , tceu_trace trace
#endif
                                                          )
{
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}
#endif

/*****************************************************************************/

typedef struct tceu_input_CEU_WCLOCK {
} tceu_input_CEU_WCLOCK;
typedef struct tceu_output_OUT {
    int _1;
    bool _2;
} tceu_output_OUT;
typedef struct tceu_output_mem_OUT {
    struct {
#line 8 "./libraries/driver-gpio/out.ceu"
int  pin;
#line 8 "./libraries/driver-gpio/out.ceu"
bool  v;
union {
struct {
union {
};
};
};
};
} tceu_output_mem_OUT;
typedef struct tceu_input_USART_RX {
} tceu_input_USART_RX;
typedef struct tceu_input_INT0 {
} tceu_input_INT0;
typedef struct tceu_output_OUT_13 {
    bool _1;
} tceu_output_OUT_13;

typedef struct tceu_event___lpar____rpar__ {
} tceu_event___lpar____rpar__;
typedef struct tceu_event___lpar__bool__rpar__ {
    bool _1;
} tceu_event___lpar__bool__rpar__;

typedef struct tceu_code_mem_WCLOCK_Now {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
u32  _ret;
union {
struct {
union {
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_WCLOCK_Now;
typedef struct tceu_code_mem_WCLOCK_Freeze {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
u32  us;
union {
union {
};
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_WCLOCK_Freeze;
typedef struct tceu_code_mem_USART_Init {
    tceu_code_mem _mem;
    tceu_trl      _trails[5];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
struct {
#line 46 "./libraries/driver-usart/avr/usart.ceu"
int  bps;
union {
union {
};
struct {
union {
struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
};
};
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_USART_Init;
typedef struct tceu_code_mem_USART_Rx {
    tceu_code_mem _mem;
    tceu_trl      _trails[5];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
struct {
#line 62 "./libraries/driver-usart/avr/usart.ceu"
tceu_vector* buf;
#line 62 "./libraries/driver-usart/avr/usart.ceu"
tceu_opt_usize  n;
union {
union {
};
union {
};
struct {
union {
struct {
union {
struct {
union {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
union {
struct {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_USART_Rx;
typedef struct tceu_code_mem_INT0_Get {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 5 "./libraries/driver-gpio/avr/int0.ceu"
bool  _ret;
union {
struct {
union {
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_INT0_Get;
typedef struct tceu_code_mem_DSensor_INT0 {
    tceu_code_mem _mem;
    tceu_trl      _trails[5];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
struct {
#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
tceu_opt_int  energyPort;
#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
tceu_opt_int  time;
#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
tceu_opt_int  debounce;
union {
union {
};
union {
};
union {
};
struct {
#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
union {
struct {
union {
struct {
union {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
union {
struct {
union {
struct {
union {
s32 __wclk_314;
};
};
struct {
union {
s32 __wclk_320;
};
};
};
};
struct {
union {
};
};
struct {
struct {
#line 38 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
bool  v_354;
union {
struct {
union {
s32 __wclk_337;
};
};
struct {
union {
s32 __wclk_343;
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_DSensor_INT0;
typedef struct tceu_code_mem_String_Check {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 74 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
union {
union {
};
struct {
union {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Check;
typedef struct tceu_code_mem_String_Print {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 83 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str;
union {
union {
};
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Print;
typedef struct tceu_code_mem_String_Append_STR {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 90 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
#line 90 "/home/anny/dev/ceu/include/string.ceu"
char*  src;
union {
union {
};
union {
};
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Append_STR;
typedef struct tceu_code_mem_String_Append_INT {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 96 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
#line 96 "/home/anny/dev/ceu/include/string.ceu"
int  src;
#line 96 "/home/anny/dev/ceu/include/string.ceu"
tceu_opt_int  base;
union {
union {
};
union {
};
union {
};
struct {
union {
struct {
#line 105 "/home/anny/dev/ceu/include/string.ceu"
usize  n;
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Append_INT;
typedef struct tceu_code_mem_String_Append_REAL {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 110 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
#line 110 "/home/anny/dev/ceu/include/string.ceu"
r64  src;
#line 110 "/home/anny/dev/ceu/include/string.ceu"
tceu_opt_int  precision;
union {
union {
};
union {
};
union {
};
struct {
union {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Append_REAL;
typedef struct tceu_code_mem_String_Equal {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 131 "/home/anny/dev/ceu/include/string.ceu"
bool  _ret;
union {
struct {
#line 131 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str1;
#line 131 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str2;
union {
union {
};
union {
};
struct {
union {
struct {
#line 132 "/home/anny/dev/ceu/include/string.ceu"
int  result;
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Equal;
typedef struct tceu_code_mem_String_Equal_STR {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 144 "/home/anny/dev/ceu/include/string.ceu"
bool  _ret;
union {
struct {
#line 144 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str1;
#line 144 "/home/anny/dev/ceu/include/string.ceu"
char*  str2;
union {
union {
};
union {
};
struct {
union {
struct {
#line 145 "/home/anny/dev/ceu/include/string.ceu"
int  result;
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Equal_STR;
typedef struct tceu_code_mem_ROOT {
    tceu_code_mem _mem;
    tceu_trl      _trails[9];
    byte          _params[0];
    struct {
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
int  _RET;
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 14 "./libraries/driver-wclock/avr/timer1-compa.ceu"
#line 67 "./libraries/driver-wclock/avr/../wclock.ceu"
#line 5 "./libraries/driver-gpio/out.ceu"
#line 8 "./libraries/driver-gpio/out.ceu"
#line 26 "./libraries/driver-usart/avr/usart.ceu"
#line 28 "./libraries/driver-usart/avr/usart.ceu"
#line 30 "./libraries/driver-usart/avr/usart.ceu"
#line 30 "./libraries/driver-usart/avr/usart.ceu"
#line 1 "./libraries/driver-gpio/avr/int0.ceu"
#line 9 "./libraries/driver-gpio/avr/int0.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 8 "/home/anny/dev/ceu/include/string.ceu"
#line 9 "/home/anny/dev/ceu/include/string.ceu"
#line 7 "libraries/driver-gpio/examples/out-01.ceu"
union {
struct {
#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
#line 5 "./libraries/driver-usart/avr/../usart.ceu"
#line 6 "./libraries/driver-usart/avr/../usart.ceu"
#line 17 "./libraries/driver-usart/avr/usart.ceu"
tceu_data_Lock  usart_lock;
#line 18 "./libraries/driver-usart/avr/usart.ceu"
u8  usart_pm_refs;
#line 20 "./libraries/driver-usart/avr/usart.ceu"
byte usart_rx_buf_102_buf[32];
tceu_vector usart_rx_buf_102;
#line 5 "./libraries/driver-gpio/avr/int0.ceu"
#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
#line 74 "/home/anny/dev/ceu/include/string.ceu"
#line 83 "/home/anny/dev/ceu/include/string.ceu"
#line 90 "/home/anny/dev/ceu/include/string.ceu"
#line 96 "/home/anny/dev/ceu/include/string.ceu"
#line 110 "/home/anny/dev/ceu/include/string.ceu"
#line 131 "/home/anny/dev/ceu/include/string.ceu"
#line 144 "/home/anny/dev/ceu/include/string.ceu"
union {
struct {
union {
tceu_code_mem_USART_Init __mem_775;
};
union {
struct {
struct {
union {
struct {
struct {
union {
struct {
struct {
#line 14 "libraries/driver-gpio/examples/out-01.ceu"
byte str_783_buf[2];
tceu_vector str_783;
union {
tceu_code_mem_USART_Rx __mem_791;
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
struct {
union {
struct {
struct {
union {
struct {
#line 24 "libraries/driver-gpio/examples/out-01.ceu"
struct tceu_code_mem_DSensor_INT0* mysensor_823;
#line 25 "libraries/driver-gpio/examples/out-01.ceu"
bool  v_836;
union {
struct {
union {
tceu_code_mem_DSensor_INT0 __mem_821;
};
union {
};
};
};
};
s32 __wclk_847;
};
};
};
};
};
};
struct {
struct {
#line 35 "libraries/driver-gpio/examples/out-01.ceu"
byte str_865_buf[2];
tceu_vector str_865;
union {
tceu_code_mem_USART_Rx __mem_873;
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
};
};
};
};
} tceu_code_mem_ROOT;



enum {
    CEU_LABEL_NONE = 0,
    CEU_LABEL_ROOT,
CEU_LABEL_Block__CLR_2,
CEU_LABEL_Block__CLR_3,
CEU_LABEL_WCLOCK_Now_Block__CLR_4,
CEU_LABEL_WCLOCK_Now_Block__CLR_5,
CEU_LABEL_WCLOCK_Now_Block__CLR_6,
CEU_LABEL_WCLOCK_Now_Do__OUT_7,
CEU_LABEL_WCLOCK_Now_Do__CLR_8,
CEU_LABEL_WCLOCK_Now_Block__CLR_9,
CEU_LABEL_Code_WCLOCK_Now,
CEU_LABEL_WCLOCK_Now_Code_WCLOCK_Now__TERM_11,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_12,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_13,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_14,
CEU_LABEL_WCLOCK_Freeze_Do__OUT_15,
CEU_LABEL_WCLOCK_Freeze_Do__CLR_16,
CEU_LABEL_WCLOCK_Freeze_Block__CLR_17,
CEU_LABEL_Code_WCLOCK_Freeze,
CEU_LABEL_WCLOCK_Freeze_Code_WCLOCK_Freeze__TERM_19,
CEU_LABEL_Block__CLR_20,
CEU_LABEL_Async_Isr__FIN_21,
CEU_LABEL_Block__CLR_22,
CEU_LABEL_Do__OUT_23,
CEU_LABEL_Do__CLR_24,
CEU_LABEL_Block__CLR_25,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_26,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_27,
CEU_LABEL_USART_Init_Par_Or__OUT_28,
CEU_LABEL_USART_Init_Par_Or__CLR_29,
CEU_LABEL_USART_Init_Block__CLR_30,
CEU_LABEL_USART_Init_Finalize_Case__IN_31,
CEU_LABEL_USART_Init_Block__CLR_32,
CEU_LABEL_USART_Init_Block__CLR_33,
CEU_LABEL_USART_Init_Do__OUT_34,
CEU_LABEL_USART_Init_Do__CLR_35,
CEU_LABEL_USART_Init_Block__CLR_36,
CEU_LABEL_Code_USART_Init,
CEU_LABEL_USART_Init_Code_USART_Init__TERM_38,
CEU_LABEL_USART_Rx_Par_Or_sub_1_IN_39,
CEU_LABEL_USART_Rx_Par_Or_sub_2_IN_40,
CEU_LABEL_USART_Rx_Par_Or__OUT_41,
CEU_LABEL_USART_Rx_Par_Or__CLR_42,
CEU_LABEL_USART_Rx_Block__CLR_43,
CEU_LABEL_USART_Rx_Finalize_Case__IN_44,
CEU_LABEL_USART_Rx_Block__CLR_45,
CEU_LABEL_USART_Rx_Block__CLR_46,
CEU_LABEL_USART_Rx_Do__OUT_47,
CEU_LABEL_USART_Rx_Do__CLR_48,
CEU_LABEL_USART_Rx_Block__CLR_49,
CEU_LABEL_Code_USART_Rx,
CEU_LABEL_USART_Rx_Code_USART_Rx__TERM_51,
CEU_LABEL_Block__CLR_52,
CEU_LABEL_Async_Isr__FIN_53,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_54,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_55,
CEU_LABEL_USART_Init_Par_Or__OUT_56,
CEU_LABEL_USART_Init_Par_Or__CLR_57,
CEU_LABEL_USART_Init_Block__CLR_58,
CEU_LABEL_USART_Init_Finalize_Case__IN_59,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_60,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_61,
CEU_LABEL_USART_Init_Par_Or__OUT_62,
CEU_LABEL_USART_Init_Par_Or__CLR_63,
CEU_LABEL_USART_Init_Block__CLR_64,
CEU_LABEL_USART_Init_Finalize_Case__IN_65,
CEU_LABEL_USART_Init_Block__CLR_66,
CEU_LABEL_USART_Init_Block__CLR_67,
CEU_LABEL_USART_Init_Block__CLR_68,
CEU_LABEL_USART_Init_Do__OUT_69,
CEU_LABEL_USART_Init_Do__CLR_70,
CEU_LABEL_USART_Init_Block__CLR_71,
CEU_LABEL_USART_Init_Code_USART_Init__TERM_72,
CEU_LABEL_USART_Rx_Par_Or_sub_1_IN_73,
CEU_LABEL_USART_Rx_Par_Or_sub_2_IN_74,
CEU_LABEL_USART_Rx_Par_Or__OUT_75,
CEU_LABEL_USART_Rx_Par_Or__CLR_76,
CEU_LABEL_USART_Rx_Block__CLR_77,
CEU_LABEL_USART_Rx_Finalize_Case__IN_78,
CEU_LABEL_USART_Rx_Par_Or_sub_1_IN_79,
CEU_LABEL_USART_Rx_Par_Or_sub_2_IN_80,
CEU_LABEL_USART_Rx_Par_Or__OUT_81,
CEU_LABEL_USART_Rx_Par_Or__CLR_82,
CEU_LABEL_USART_Rx_Block__CLR_83,
CEU_LABEL_USART_Rx_Block__CLR_84,
CEU_LABEL_USART_Rx_Block__CLR_85,
CEU_LABEL_USART_Rx_Finalize_Case__IN_86,
CEU_LABEL_USART_Rx_Block__CLR_87,
CEU_LABEL_USART_Rx_Block__CLR_88,
CEU_LABEL_USART_Rx_Block__CLR_89,
CEU_LABEL_USART_Rx_Await_USART_RX__OUT_90,
CEU_LABEL_USART_Rx_Block__CLR_91,
CEU_LABEL_USART_Rx_Loop__CLR_92,
CEU_LABEL_USART_Rx_Loop_Continue__CNT_93,
CEU_LABEL_USART_Rx_Loop_Continue__CLR_94,
CEU_LABEL_USART_Rx_Loop_Break__OUT_95,
CEU_LABEL_USART_Rx_Block__CLR_96,
CEU_LABEL_USART_Rx_Block__CLR_97,
CEU_LABEL_USART_Rx_Block__CLR_98,
CEU_LABEL_USART_Rx_Do__OUT_99,
CEU_LABEL_USART_Rx_Do__CLR_100,
CEU_LABEL_USART_Rx_Block__CLR_101,
CEU_LABEL_USART_Rx_Code_USART_Rx__TERM_102,
CEU_LABEL_INT0_Get_Block__CLR_103,
CEU_LABEL_INT0_Get_Block__CLR_104,
CEU_LABEL_INT0_Get_Block__CLR_105,
CEU_LABEL_INT0_Get_Do__OUT_106,
CEU_LABEL_INT0_Get_Do__CLR_107,
CEU_LABEL_INT0_Get_Block__CLR_108,
CEU_LABEL_Code_INT0_Get,
CEU_LABEL_INT0_Get_Code_INT0_Get__TERM_110,
CEU_LABEL_Block__CLR_111,
CEU_LABEL_Async_Isr__FIN_112,
CEU_LABEL_DSensor_INT0_Par_Or_sub_1_IN_113,
CEU_LABEL_DSensor_INT0_Par_Or_sub_2_IN_114,
CEU_LABEL_DSensor_INT0_Par_Or__OUT_115,
CEU_LABEL_DSensor_INT0_Par_Or__CLR_116,
CEU_LABEL_DSensor_INT0_Block__CLR_117,
CEU_LABEL_DSensor_INT0_Finalize_Case__IN_118,
CEU_LABEL_DSensor_INT0_Par_Or_sub_1_IN_119,
CEU_LABEL_DSensor_INT0_Par_Or_sub_2_IN_120,
CEU_LABEL_DSensor_INT0_Par_Or__OUT_121,
CEU_LABEL_DSensor_INT0_Par_Or__CLR_122,
CEU_LABEL_DSensor_INT0_Block__CLR_123,
CEU_LABEL_DSensor_INT0_Block__CLR_124,
CEU_LABEL_DSensor_INT0_Block__CLR_125,
CEU_LABEL_DSensor_INT0_Finalize_Case__IN_126,
CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_127,
CEU_LABEL_DSensor_INT0_Block__CLR_128,
CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_129,
CEU_LABEL_DSensor_INT0_Block__CLR_130,
CEU_LABEL_DSensor_INT0_Block__CLR_131,
CEU_LABEL_DSensor_INT0_Block__CLR_132,
CEU_LABEL_DSensor_INT0_Await_INT0__OUT_133,
CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_134,
CEU_LABEL_DSensor_INT0_Block__CLR_135,
CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_136,
CEU_LABEL_DSensor_INT0_Block__CLR_137,
CEU_LABEL_DSensor_INT0_Emit_Int__OUT_138,
CEU_LABEL_DSensor_INT0_Block__CLR_139,
CEU_LABEL_DSensor_INT0_Loop__CLR_140,
CEU_LABEL_DSensor_INT0_Loop_Continue__CNT_141,
CEU_LABEL_DSensor_INT0_Loop_Continue__CLR_142,
CEU_LABEL_DSensor_INT0_Loop_Break__OUT_143,
CEU_LABEL_DSensor_INT0_Block__CLR_144,
CEU_LABEL_DSensor_INT0_Block__CLR_145,
CEU_LABEL_DSensor_INT0_Block__CLR_146,
CEU_LABEL_DSensor_INT0_Do__OUT_147,
CEU_LABEL_DSensor_INT0_Do__CLR_148,
CEU_LABEL_DSensor_INT0_Block__CLR_149,
CEU_LABEL_Code_DSensor_INT0,
CEU_LABEL_DSensor_INT0_Code_DSensor_INT0__TERM_151,
CEU_LABEL_String_Check_Block__CLR_152,
CEU_LABEL_String_Check_Block__CLR_153,
CEU_LABEL_String_Check_Block__CLR_154,
CEU_LABEL_String_Check_Block__CLR_155,
CEU_LABEL_String_Check_Block__CLR_156,
CEU_LABEL_String_Check_Do__OUT_157,
CEU_LABEL_String_Check_Do__CLR_158,
CEU_LABEL_String_Check_Block__CLR_159,
CEU_LABEL_Code_String_Check,
CEU_LABEL_String_Check_Code_String_Check__TERM_161,
CEU_LABEL_String_Print_Block__CLR_162,
CEU_LABEL_String_Print_Block__CLR_163,
CEU_LABEL_String_Print_Block__CLR_164,
CEU_LABEL_String_Print_Do__OUT_165,
CEU_LABEL_String_Print_Do__CLR_166,
CEU_LABEL_String_Print_Block__CLR_167,
CEU_LABEL_Code_String_Print,
CEU_LABEL_String_Print_Code_String_Print__TERM_169,
CEU_LABEL_String_Append_STR_Block__CLR_170,
CEU_LABEL_String_Append_STR_Block__CLR_171,
CEU_LABEL_String_Append_STR_Block__CLR_172,
CEU_LABEL_String_Append_STR_Do__OUT_173,
CEU_LABEL_String_Append_STR_Do__CLR_174,
CEU_LABEL_String_Append_STR_Block__CLR_175,
CEU_LABEL_Code_String_Append_STR,
CEU_LABEL_String_Append_STR_Code_String_Append_STR__TERM_177,
CEU_LABEL_String_Append_INT_Block__CLR_178,
CEU_LABEL_String_Append_INT_Block__CLR_179,
CEU_LABEL_String_Append_INT_Block__CLR_180,
CEU_LABEL_String_Append_INT_Block__CLR_181,
CEU_LABEL_String_Append_INT_Block__CLR_182,
CEU_LABEL_String_Append_INT_Do__OUT_183,
CEU_LABEL_String_Append_INT_Do__CLR_184,
CEU_LABEL_String_Append_INT_Block__CLR_185,
CEU_LABEL_Code_String_Append_INT,
CEU_LABEL_String_Append_INT_Code_String_Append_INT__TERM_187,
CEU_LABEL_String_Append_REAL_Block__CLR_188,
CEU_LABEL_String_Append_REAL_Block__CLR_189,
CEU_LABEL_String_Append_REAL_Block__CLR_190,
CEU_LABEL_String_Append_REAL_Block__CLR_191,
CEU_LABEL_String_Append_REAL_Block__CLR_192,
CEU_LABEL_String_Append_REAL_Do__OUT_193,
CEU_LABEL_String_Append_REAL_Do__CLR_194,
CEU_LABEL_String_Append_REAL_Block__CLR_195,
CEU_LABEL_Code_String_Append_REAL,
CEU_LABEL_String_Append_REAL_Code_String_Append_REAL__TERM_197,
CEU_LABEL_String_Equal_Block__CLR_198,
CEU_LABEL_String_Equal_Block__CLR_199,
CEU_LABEL_String_Equal_Block__CLR_200,
CEU_LABEL_String_Equal_Block__CLR_201,
CEU_LABEL_String_Equal_Block__CLR_202,
CEU_LABEL_String_Equal_Do__OUT_203,
CEU_LABEL_String_Equal_Do__CLR_204,
CEU_LABEL_String_Equal_Block__CLR_205,
CEU_LABEL_Code_String_Equal,
CEU_LABEL_String_Equal_Code_String_Equal__TERM_207,
CEU_LABEL_String_Equal_STR_Block__CLR_208,
CEU_LABEL_String_Equal_STR_Block__CLR_209,
CEU_LABEL_String_Equal_STR_Block__CLR_210,
CEU_LABEL_String_Equal_STR_Block__CLR_211,
CEU_LABEL_String_Equal_STR_Block__CLR_212,
CEU_LABEL_String_Equal_STR_Do__OUT_213,
CEU_LABEL_String_Equal_STR_Do__CLR_214,
CEU_LABEL_String_Equal_STR_Block__CLR_215,
CEU_LABEL_Code_String_Equal_STR,
CEU_LABEL_String_Equal_STR_Code_String_Equal_STR__TERM_217,
CEU_LABEL_Par_Or_sub_1_IN_218,
CEU_LABEL_Par_Or_sub_2_IN_219,
CEU_LABEL_Par_Or__OUT_220,
CEU_LABEL_Par_Or__CLR_221,
CEU_LABEL_Await_Spawn__OUT_222,
CEU_LABEL_Par_Or_sub_1_IN_223,
CEU_LABEL_Par_Or_sub_2_IN_224,
CEU_LABEL_Par_Or__OUT_225,
CEU_LABEL_Par_Or__CLR_226,
CEU_LABEL_Await_Await__OUT_227,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_228,
CEU_LABEL_Block__CLR_229,
CEU_LABEL_Block__CLR_230,
CEU_LABEL_Block__CLR_231,
CEU_LABEL_Loop__CLR_232,
CEU_LABEL_Loop_Continue__CNT_233,
CEU_LABEL_Loop_Continue__CLR_234,
CEU_LABEL_Loop_Break__OUT_235,
CEU_LABEL_Block__CLR_236,
CEU_LABEL_Par_Or_sub_1_IN_237,
CEU_LABEL_Par_Or_sub_2_IN_238,
CEU_LABEL_Par_Or__OUT_239,
CEU_LABEL_Par_Or__CLR_240,
CEU_LABEL_Await_Spawn__OUT_241,
CEU_LABEL_Await_change__OUT_242,
CEU_LABEL_Block__CLR_243,
CEU_LABEL_Do__OUT_244,
CEU_LABEL_Do__CLR_245,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_246,
CEU_LABEL_Await_Wclock__OUT_247,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_248,
CEU_LABEL_Block__CLR_249,
CEU_LABEL_Loop__CLR_250,
CEU_LABEL_Loop_Continue__CNT_251,
CEU_LABEL_Loop_Continue__CLR_252,
CEU_LABEL_Loop_Break__OUT_253,
CEU_LABEL_Block__CLR_254,
CEU_LABEL_Await_Await__OUT_255,
CEU_LABEL_Emit_Ext_emit__OUT_13__OUT_256,
CEU_LABEL_Block__CLR_257,
CEU_LABEL_Block__CLR_258,
CEU_LABEL_Block__CLR_259,
CEU_LABEL_Loop__CLR_260,
CEU_LABEL_Loop_Continue__CNT_261,
CEU_LABEL_Loop_Continue__CLR_262,
CEU_LABEL_Loop_Break__OUT_263,
CEU_LABEL_Block__CLR_264,
CEU_LABEL_Loop__CLR_265,
CEU_LABEL_Loop_Continue__CNT_266,
CEU_LABEL_Loop_Continue__CLR_267,
CEU_LABEL_Loop_Break__OUT_268,
CEU_LABEL_Block__CLR_269,
CEU_LABEL_Do__OUT_270,
CEU_LABEL_Do__CLR_271,
CEU_LABEL_Block__CLR_272,

};

/*****************************************************************************/

typedef struct tceu_app {
#ifdef CEU_FEATURES_OS
    int    argc;
    char** argv;

    bool end_ok;
    int  end_val;
#endif

    /* ASYNC */
#ifdef CEU_FEATURES_ASYNC
    bool async_pending;
#endif

    /* WCLOCK */
    s32 wclk_late;
    s32 wclk_min_set;
    s32 wclk_min_cmp;

#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_T threads_mutex;
    tceu_threads_data*  threads_head;   /* linked list of threads alive */
    tceu_threads_data** cur_;           /* TODO: HACK_6 "gc" mutable iterator */
#endif

    byte  stack[CEU_STACK_N];
    usize stack_i;

    tceu_code_mem_ROOT root;
} tceu_app;

CEU_API static tceu_app CEU_APP;

/*****************************************************************************/

__attribute__((__unused__))
static tceu_code_mem* ceu_outer (tceu_code_mem* mem, u8 n) {
    for (; mem->depth!=n; mem=mem->up_mem);
    return mem;
}

/*****************************************************************************/

#define CEU_WCLOCK_INACTIVE INT32_MAX

#ifdef CEU_FEATURES_TRACE
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c,d)
#else
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c)
#endif

__attribute__((__unused__))
static int ceu_wclock_ (s32 dt, s32* set, s32* sub
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
                      )
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "sub") */

    /* SET */
    if (set != NULL) {
        t = dt - CEU_APP.wclk_late;
        *set = t;

    /* SUB */
    } else {
        t = *sub;
        if ((t > CEU_APP.wclk_min_cmp) || (t > dt)) {
            *sub -= dt;    /* don't expire yet */
            t = *sub;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (CEU_APP.wclk_min_set > t) ) {
        CEU_APP.wclk_min_set = t;
        ceu_callback_wclock_min(t, CEU_TRACE_null);
    }

    return ret;
}

__attribute__((__unused__))
static void ceu_params_cpy (tceu_stk* stk, void* params, usize params_n) {
    ceu_assert_sys(CEU_APP.stack_i+params_n < CEU_STACK_N, "stack overflow");
    memcpy(&CEU_APP.stack[CEU_APP.stack_i], params, params_n);
    stk->params   = &CEU_APP.stack[CEU_APP.stack_i];
    stk->params_n = params_n;
    CEU_APP.stack_i += stk->params_n;
}

/*****************************************************************************/

static void ceu_stack_clear (tceu_stk* cur, tceu_code_mem* mem) {
    if (cur == NULL) {
        return;
    }
    if (cur->range.mem == mem) {
        cur->is_alive = 0;
    }
    ceu_stack_clear(cur->prv, mem);
}

#ifdef CEU_FEATURES_POOL
static void ceu_code_mem_dyn_free (tceu_pool* pool, tceu_code_mem_dyn* cur) {
    cur->nxt->prv = cur->prv;
    cur->prv->nxt = cur->nxt;

#ifdef CEU_FEATURES_DYNAMIC
    if (pool->queue == NULL) {
        /* dynamic pool */
        ceu_callback_free(cur, CEU_TRACE_null);
    } else
#endif
    {
        /* static pool */
        ceu_pool_free(pool, (byte*)cur);
    }
}

static void ceu_code_mem_dyn_gc (tceu_pool_pak* pak) {
    if (pak->n_traversing == 0) {
        /* TODO-OPT: one element killing another is unlikely:
                     set bit in pool when this happens and only
                     traverses in this case */
        tceu_code_mem_dyn* cur = pak->first.nxt;
        while (cur != &pak->first) {
            tceu_code_mem_dyn* nxt = cur->nxt;
            if (!cur->is_alive) {
                ceu_code_mem_dyn_free(&pak->pool, cur);
            }
            cur = nxt;
        }
    }
}
#endif

/*****************************************************************************/

#ifdef CEU_FEATURES_LUA
static void ceu_lua_createargtable (lua_State* lua, char** argv, int argc, int script) {
    int i, narg;
    if (script == argc) script = 0;  /* no script name? */
    narg = argc - (script + 1);  /* number of positive indices */
    lua_createtable(lua, narg, script + 1);
    for (i = 0; i < argc; i++) {
        lua_pushstring(lua, argv[i]);
        lua_rawseti(lua, -2, i - script);
    }
    lua_setglobal(lua, "arg");
}

#endif

/*****************************************************************************/

static int ceu_lbl (tceu_nstk _ceu_level, tceu_stk* _ceu_cur, tceu_stk* _ceu_nxt, tceu_code_mem* _ceu_mem, tceu_nlbl _ceu_lbl, tceu_ntrl* _ceu_trlK);


    static bool ceu_wclock_is_active = 0;

    void ceu_arduino_callback_wclock_min (s32 dt) {
        ceu_wclock_request(dt, ceu_wclock_is_active);
        ceu_wclock_is_active = (dt != CEU_WCLOCK_INACTIVE);
        ceu_pm_set(CEU_PM_TIMER1, ceu_wclock_is_active);
    }

    s32 ceu_arduino_callback_wclock_dt (void) {
        return (ceu_wclock_is_active) ? ceu_wclock_dt() : CEU_WCLOCK_INACTIVE;
    }

    static u16 ceu_timer1_old;

    void ceu_wclock_init (void) {
        ceu_timer1_old = TCNT1;
        TCCR1A = 0;







        TCCR1B = 0b101;



    }

    void ceu_wclock_request (s32 us, bool was_active) {
        if (us == CEU_WCLOCK_INACTIVE) {
            bitClear(TIMSK1, OCIE1A);
        } else {
            s32 v = ((s32)(((double)(us))*F_CPU/1024/1000000L));
            ceu_assert(v < U16_MAX, "bug found");
            OCR1A = (ceu_timer1_old + v);
            bitSet(TIMSK1, OCIE1A);
        }
    }

    void ceu_wclock_done (void) {
        // ok
    }

    s32 ceu_wclock_dt (void) {
        u16 now = TCNT1;
        //ceu_assert(now<128, "bug found");     (not really, only if called due to CEU_WCLOCK)
        s32 dt = (u16)(now - ceu_timer1_old);
        ceu_timer1_old = now;
        return ((s32)(((double)(dt))*1000000L*1024/F_CPU)+1);
    }

    u32 ceu_wclock_now (void) {
        return ((s32)(((double)(TCNT1))*1000000L*1024/F_CPU)+1);
    }

#define ceu_callback_output_OUT_13(ps,trace) digitalWrite(13, *((bool*)ps))

#define PURIFY(e) e


static u32 /* space */
CEU_CODE_WCLOCK_Now (tceu_code_mem_WCLOCK_Now mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_WCLOCK_Now* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_WCLOCK_Now;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}
static none /* space */
CEU_CODE_WCLOCK_Freeze (tceu_code_mem_WCLOCK_Freeze mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_WCLOCK_Freeze* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_WCLOCK_Freeze;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static tceu_nlbl CEU_CODE_USART_Init_to_lbl (tceu_code_mem_USART_Init* mem)
{
    tceu_nlbl lbl = CEU_LABEL_Code_USART_Init;
    return lbl;
}
static tceu_nlbl CEU_CODE_USART_Rx_to_lbl (tceu_code_mem_USART_Rx* mem)
{
    tceu_nlbl lbl = CEU_LABEL_Code_USART_Rx;
    return lbl;
}
static bool /* space */
CEU_CODE_INT0_Get (tceu_code_mem_INT0_Get mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_INT0_Get* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_INT0_Get;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}
static tceu_nlbl CEU_CODE_DSensor_INT0_to_lbl (tceu_code_mem_DSensor_INT0* mem)
{
    tceu_nlbl lbl = CEU_LABEL_Code_DSensor_INT0;
    return lbl;
}
static none /* space */
CEU_CODE_String_Check (tceu_code_mem_String_Check mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Check* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Check;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Print (tceu_code_mem_String_Print mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Print* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Print;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Append_STR (tceu_code_mem_String_Append_STR mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Append_STR* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Append_STR;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Append_INT (tceu_code_mem_String_Append_INT mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Append_INT* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Append_INT;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Append_REAL (tceu_code_mem_String_Append_REAL mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Append_REAL* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Append_REAL;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static bool /* space */
CEU_CODE_String_Equal (tceu_code_mem_String_Equal mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Equal* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Equal;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}
static bool /* space */
CEU_CODE_String_Equal_STR (tceu_code_mem_String_Equal_STR mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Equal_STR* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Equal_STR;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}


#ifdef CEU_FEATURES_TRACE
#define ceu_callback_output_OUT(a,b) ceu_callback_output_OUT_(a,b)
#else
#define ceu_callback_output_OUT(a,b) ceu_callback_output_OUT_(a)
#endif
int ceu_callback_output_OUT_ (tceu_output_OUT* ps
#ifdef CEU_FEATURES_TRACE
                                                                  , tceu_trace trace
#endif
                                                                  )
{
#define CEU_TRACE(n) trace
    tceu_output_mem_OUT _ceu_loc;

/* Block (n=68, ln=9) */

#line 9 "./libraries/driver-gpio/out.ceu"
{

/* Stmt_Call (n=66, ln=9) */

#line 9 "./libraries/driver-gpio/out.ceu"
digitalWrite((((*ps)._1)),(((*ps)._2)));

/* Block (n=68, ln=9) */

#line 9 "./libraries/driver-gpio/out.ceu"
}

/* Do (n=1208, ln=8) */

#line 8 "./libraries/driver-gpio/out.ceu"
CEU_LABEL_Do__OUT_23:;
#undef CEU_TRACE
return 0;
}


typedef struct tceu_isr_mem_47 {
    struct {
union {
};
};
} tceu_isr_mem_47;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(TIMER1_COMPA_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_47 _ceu_loc;
    
/* Block (n=46, ln=69) */

#line 69 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Nat_Stmt (n=41, ln=69) */

#line 69 "./libraries/driver-wclock/avr/../wclock.ceu"
ceu_wclock_done();
/* Emit_Ext_emit (n=44, ln=70) */

#line 70 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Emit_Ext_emit (n=44, ln=70) */

#line 70 "./libraries/driver-wclock/avr/../wclock.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_CEU_WCLOCK,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(0, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_CEU_WCLOCK,{NULL}}).id, NULL };
    ceu_callback_isr_emit(TIMER1_COMPA_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=44, ln=70) */

#line 70 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=46, ln=69) */

#line 69 "./libraries/driver-wclock/avr/../wclock.ceu"
}
}
typedef struct tceu_isr_mem_128 {
    struct {
union {
};
};
} tceu_isr_mem_128;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(USART_RX_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_128 _ceu_loc;
    
/* Block (n=127, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
{

/* Set_Vec (n=121, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=121, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
    __ceu_nxt = ((CEU_APP.root.usart_rx_buf_102)).len;

/* Set_Vec (n=121, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
    __ceu_nxt = ((CEU_APP.root.usart_rx_buf_102)).len;

/* Set_Vec (n=121, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
    ceu_vector_setlen(&((CEU_APP.root.usart_rx_buf_102)), (((CEU_APP.root.usart_rx_buf_102)).len + 1), 1);

/* Set_Vec (n=121, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
    *((byte*)
        ceu_vector_buf_get(&((CEU_APP.root.usart_rx_buf_102)), __ceu_nxt++)) = UDR0;

/* Set_Vec (n=121, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"

/* Set_Vec (n=121, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
}

/* Emit_Ext_emit (n=125, ln=39) */

#line 39 "./libraries/driver-usart/avr/usart.ceu"
{

/* Emit_Ext_emit (n=125, ln=39) */

#line 39 "./libraries/driver-usart/avr/usart.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_RX,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(2, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_RX,{NULL}}).id, NULL };
    ceu_callback_isr_emit(USART_RX_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=125, ln=39) */

#line 39 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=127, ln=38) */

#line 38 "./libraries/driver-usart/avr/usart.ceu"
}
}
typedef struct tceu_isr_mem_270 {
    struct {
union {
};
};
} tceu_isr_mem_270;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(INT0_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_270 _ceu_loc;
    
/* Block (n=269, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Emit_Ext_emit (n=267, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Emit_Ext_emit (n=267, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_INT0,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(3, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_INT0,{NULL}}).id, NULL };
    ceu_callback_isr_emit(INT0_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=267, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Block (n=269, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
}
}




/*****************************************************************************/

#ifdef CEU_FEATURES_EXCEPTION
static int ceu_throw_ex (tceu_catch* catches, tceu_data_Exception* exception, usize len
                  , tceu_nstk level, tceu_stk* nxt
#ifdef CEU_FEATURES_TRACE
                  , tceu_trace trace
#endif
                  )
{
    tceu_catch* cur = catches;
    while (cur != NULL) {
        if (ceu_data_is(CEU_DATA_SUPERS_Exception,exception->_enum,cur->exception->value._enum)) {
            //ceu_sys_assert(!cur->exception->is_set, "double catch");
            ceu_assert_ex(!cur->exception->is_set, "double catch", trace);
            cur->exception->is_set = 1;
            memcpy(&cur->exception->value, exception, len);

#if 0
            /* do not allow nested catches (and itself) to awake */
            cur->exception = NULL;
            while (catches != cur) {
                catches->exception = NULL;
                catches = catches->up;
            }
#endif

            //return ceu_lbl(NULL, stk, cur->mem, cur->trl, cur->mem->_trails[cur->trl].lbl);
            //return ceu_lbl(_ceu_level, _ceu_cur, _ceu_nxt, _ceu_mem, _ceu_lbl, _ceu_trlK)
            cur->mem->_trails[cur->trl].evt.id = CEU_INPUT__STACKED;
            cur->mem->_trails[cur->trl].level = level + 1;
//printf(">>> %d %d\n", cur->trl, cur->mem->_trails[cur->trl].lbl);
            tceu_evt   evt   = {CEU_INPUT__NONE, {NULL}};
            //tceu_range range = { cur->mem, cur->trl, cur->trl };
            tceu_range range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
            nxt->evt      = evt;
            nxt->range    = range;
            nxt->params_n = 0;
            return 1;
        }
        cur = cur->up;
    }
    ceu_assert_ex(0, exception->message, trace);
    return 0;
}
#ifdef CEU_FEATURES_TRACE
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_level,_ceu_nxt,CEU_TRACE(0))
#else
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_level,_ceu_nxt)
#endif
#endif

#ifdef CEU_FEATURES_THREAD
static int ceu_threads_gc (int force_join) {
    int n_alive = 0;
    CEU_APP.cur_ = &CEU_APP.threads_head;
    tceu_threads_data*  head  = *CEU_APP.cur_;
    while (head != NULL) {
        tceu_threads_data** nxt_ = &head->nxt;
        if (head->has_terminated || head->has_aborted)
        {
            if (!head->has_notified) {
                ceu_input(CEU_INPUT__THREAD, &head->id);
                head->has_notified = 1;
            }

            /* remove from list if rejoined */
            {
                int has_joined;
                if (force_join || head->has_terminated) {
                    CEU_THREADS_JOIN(head->id);
                    has_joined = 1;
                } else {
                    /* possible with "CANCEL" which prevents setting "has_terminated" */
                    has_joined = CEU_THREADS_JOIN_TRY(head->id);
                }
                if (has_joined) {
                    *CEU_APP.cur_ = head->nxt;
                    nxt_ = CEU_APP.cur_;
                    ceu_callback_free(head, CEU_TRACE_null);
                }
            }
        }
        else
        {
            n_alive++;
        }
        CEU_APP.cur_ = nxt_;
        head  = *CEU_APP.cur_;
    }
    return n_alive;
}
#endif

/*****************************************************************************/

#define CEU_GOTO(lbl) {_ceu_lbl=lbl; goto _CEU_LBL_;}

static int ceu_lbl (tceu_nstk _ceu_level, tceu_stk* _ceu_cur, tceu_stk* _ceu_nxt, tceu_code_mem* _ceu_mem, tceu_nlbl _ceu_lbl, tceu_ntrl* _ceu_trlK)
{
#define CEU_TRACE(n) ((tceu_trace){&_ceu_mem->trace,__FILE__,__LINE__+(n)})
#ifdef CEU_STACK_MAX
    {
        static void* base = NULL;
        if (base == NULL) {
            base = &_ceu_level;
        } else {
#if 0
#if 0
//Serial.begin(9600);
Serial.println((usize)base);
Serial.println((usize)&_ceu_lbl);
Serial.print(" lbl "); Serial.println(_ceu_lbl);
//Serial.flush();
    if((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_level)) {
    } else {
        delay(1000);
    }
#else
printf(">>> %p / %p / %ld\n", base, &_ceu_lbl, ((u64)base)-((u64)&_ceu_lbl));
printf("%ld %ld %d\n", (usize)(base-CEU_STACK_MAX), (usize)(&_ceu_level),
            ((usize)(base-CEU_STACK_MAX) <= (usize)(&_ceu_level)));
#endif
#endif
            ceu_assert((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_level), "stack overflow");
        }
    }
#endif

_CEU_LBL_:
    //printf("-=-=- %d -=-=-\n", _ceu_lbl);
    switch (_ceu_lbl) {
        case CEU_LABEL_NONE:
            break;
        
/* ROOT (n=940, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_ROOT:;

/* Block (n=939, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Block (n=934, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Code (n=1183, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1183, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_Code_WCLOCK_Now:;

/* Block (n=1182, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=1174, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=1172, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=12, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Set_Exp (n=1184, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
(((*((tceu_code_mem_WCLOCK_Now*)_ceu_mem))._ret)) = ( ceu_wclock_now() );

/* Escape (n=10, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
CEU_GOTO(CEU_LABEL_WCLOCK_Now_Do__OUT_7);

/* Block (n=12, ln=8) */

#line 8 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=1172, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=1174, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Do (n=1175, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=1175, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_WCLOCK_Now_Do__OUT_7:;

/* Block (n=1182, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Code (n=1183, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
return 0;

/* Code (n=1183, ln=7) */

#line 7 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Code (n=1197, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1197, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_Code_WCLOCK_Freeze:;

/* Block (n=1196, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=1192, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=1190, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Block (n=28, ln=12) */

#line 12 "./libraries/driver-wclock/avr/../wclock.ceu"
{

/* Stmt_Call (n=26, ln=12) */

#line 12 "./libraries/driver-wclock/avr/../wclock.ceu"
delayMicroseconds((((*((tceu_code_mem_WCLOCK_Freeze*)_ceu_mem)).us)));

/* Block (n=28, ln=12) */

#line 12 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=1190, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Block (n=1192, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Do (n=1193, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
case CEU_LABEL_WCLOCK_Freeze_Do__OUT_15:;

/* Block (n=1196, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Code (n=1197, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
return 0;

/* Code (n=1197, ln=11) */

#line 11 "./libraries/driver-wclock/avr/../wclock.ceu"
}

/* Nat_Stmt (n=33, ln=59) */

#line 59 "./libraries/driver-wclock/avr/../wclock.ceu"

    ceu_wclock_init();

/* Nat_Stmt (n=72, ln=24) */

#line 24 "./libraries/driver-gpio/out.ceu"

#ifdef _CEU_OUTPUT_OUT_13_
    pinMode(13, OUTPUT);
#endif

/* Set_Exp (n=1697, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
((((CEU_APP.root.usart_lock)).is_locked)) = 0;

/* Set_Exp (n=97, ln=18) */

#line 18 "./libraries/driver-usart/avr/usart.ceu"
((CEU_APP.root.usart_pm_refs)) = 0;

/* Vec_Init (n=1713, ln=20) */

#line 20 "./libraries/driver-usart/avr/usart.ceu"
ceu_vector_init(&((CEU_APP.root.usart_rx_buf_102)),32, 1, 0, sizeof(byte),
                (byte*)&((CEU_APP.root.usart_rx_buf_102_buf)));

/* Code (n=1285, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1285, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_Code_USART_Init:;

/* Block (n=1284, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
{

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Init_Par_Or_sub_2_IN_55;

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or_sub_1_IN_54);

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_1_IN_54:;

/* Finalize_Case (n=2077, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Init_Finalize_Case__IN_59;

/* Finalize_Case (n=2077, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=2077, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Finalize_Case__IN_59:;

/* Block (n=1279, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
{

/* Code_Finalize (n=1277, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
if (_ceu_mem->has_term) {
    /* generate only if terminating from inside */
    _ceu_mem->_trails[1].evt.id = CEU_INPUT__STACKED;
    _ceu_mem->_trails[1].level  = _ceu_level;
    _ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Init_Code_USART_Init__TERM_72;

    tceu_evt   __ceu_evt   = { CEU_INPUT__CODE_TERMINATED, {_ceu_mem} };
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;

/* Code_Finalize (n=1277, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
_ceu_nxt->params_n = 0;

/* Code_Finalize (n=1277, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
}

#ifdef CEU_FEATURES_POOL
if (_ceu_mem->pak != NULL) {
    tceu_code_mem_dyn* __ceu_dyn =
        (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));
    __ceu_dyn->is_alive = 0;
}
#endif

ceu_stack_clear(_ceu_cur, _ceu_mem);

if (_ceu_mem->has_term) {
    _ceu_mem->has_term = 0;
    return 1;
} else {
    return 0;
}

/* Code_Finalize (n=1277, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Block (n=1279, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=2077, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=2077, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=2294, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_56);

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_2_IN_55:;

/* Block (n=1275, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=1273, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=144, ln=47) */

#line 47 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=136, ln=47) */

#line 47 "./libraries/driver-usart/avr/usart.ceu"

        UCSR0A = 1 << U2X0;
        UBRR0H = (USART_BAUD((((*((tceu_code_mem_USART_Init*)_ceu_mem)).bps)))>>8); // set baud rate
        UBRR0L = (USART_BAUD((((*((tceu_code_mem_USART_Init*)_ceu_mem)).bps))));
        UCSR0C = (1<<USBS0) | (3<<UCSZ00); // 8data, 2stop-bit
        UCSR0B = (1<<RXEN0) | (1<<RXCIE0); // enables RX & ISRS
    
/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_USART_Init_Par_Or_sub_2_IN_61;

/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or_sub_1_IN_60);

/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_1_IN_60:;

/* Finalize_Case (n=2079, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_USART_Init_Finalize_Case__IN_65;

/* Finalize_Case (n=2079, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=2079, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Finalize_Case__IN_65:;

/* Block (n=139, ln=55) */

#line 55 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=137, ln=55) */

#line 55 "./libraries/driver-usart/avr/usart.ceu"

            UCSR0B = 0; // disables TX/RX & ISRS
        
/* Block (n=139, ln=55) */

#line 55 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=2079, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=2079, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=2300, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_62);

/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_2_IN_61:;

/* Await_Forever (n=142, ln=59) */

#line 59 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Nat_Stmt (n=1719, ln=47) */

#line 47 "./libraries/driver-usart/avr/usart.ceu"
ceu_assert(0, "reached end of `code`");
/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_62);

/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__OUT_62:;

/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Init_Par_Or__CLR_63;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 2+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2303, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__CLR_63:;

/* Block (n=144, ln=47) */

#line 47 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=1273, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=1275, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
}

/* Do (n=1276, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Do__OUT_69:;

/* Do (n=1276, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
    _ceu_mem->has_term = 1;

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_56);

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__OUT_56:;

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_USART_Init_Par_Or__CLR_57;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2297, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__CLR_57:;

/* Block (n=1284, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=1285, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Code (n=1285, ln=46) */

#line 46 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=1304, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1304, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_Code_USART_Rx:;

/* Block (n=1303, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
{

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Rx_Par_Or_sub_2_IN_74;

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Rx_Par_Or_sub_1_IN_73);

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or_sub_1_IN_73:;

/* Finalize_Case (n=2081, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Rx_Finalize_Case__IN_78;

/* Finalize_Case (n=2081, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=2081, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Finalize_Case__IN_78:;

/* Block (n=1298, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
{

/* Code_Finalize (n=1296, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
if (_ceu_mem->has_term) {
    /* generate only if terminating from inside */
    _ceu_mem->_trails[1].evt.id = CEU_INPUT__STACKED;
    _ceu_mem->_trails[1].level  = _ceu_level;
    _ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Rx_Code_USART_Rx__TERM_102;

    tceu_evt   __ceu_evt   = { CEU_INPUT__CODE_TERMINATED, {_ceu_mem} };
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;

/* Code_Finalize (n=1296, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
_ceu_nxt->params_n = 0;

/* Code_Finalize (n=1296, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

#ifdef CEU_FEATURES_POOL
if (_ceu_mem->pak != NULL) {
    tceu_code_mem_dyn* __ceu_dyn =
        (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));
    __ceu_dyn->is_alive = 0;
}
#endif

ceu_stack_clear(_ceu_cur, _ceu_mem);

if (_ceu_mem->has_term) {
    _ceu_mem->has_term = 0;
    return 1;
} else {
    return 0;
}

/* Code_Finalize (n=1296, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Block (n=1298, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=2081, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=2081, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=2306, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Rx_Par_Or__OUT_75);

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or_sub_2_IN_74:;

/* Block (n=1294, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=1292, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=235, ln=64) */

#line 64 "./libraries/driver-usart/avr/usart.ceu"
{

/* Set_Exp (n=164, ln=64) */

#line 64 "./libraries/driver-usart/avr/usart.ceu"
((CEU_APP.root.usart_pm_refs)) = (((CEU_APP.root.usart_pm_refs))+1);

/* Nat_Stmt (n=166, ln=65) */

#line 65 "./libraries/driver-usart/avr/usart.ceu"
ceu_pm_set(CEU_PM_USART, 1);
/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_USART_Rx_Par_Or_sub_2_IN_80;

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Rx_Par_Or_sub_1_IN_79);

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or_sub_1_IN_79:;

/* Finalize_Case (n=2083, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_USART_Rx_Finalize_Case__IN_86;

/* Finalize_Case (n=2083, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=2083, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Finalize_Case__IN_86:;

/* Block (n=185, ln=67) */

#line 67 "./libraries/driver-usart/avr/usart.ceu"
{

/* Set_Exp (n=174, ln=67) */

#line 67 "./libraries/driver-usart/avr/usart.ceu"
((CEU_APP.root.usart_pm_refs)) = (((CEU_APP.root.usart_pm_refs))-1);

/* If (n=183, ln=68) */

#line 68 "./libraries/driver-usart/avr/usart.ceu"
if ((((CEU_APP.root.usart_pm_refs))==0)) {
    
/* Block (n=182, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=180, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
ceu_pm_set(CEU_PM_USART, 0);
/* Block (n=182, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}
} else {
    
/* Block (n=1308, ln=68) */

#line 68 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=1308, ln=68) */

#line 68 "./libraries/driver-usart/avr/usart.ceu"
}
}

/* Block (n=185, ln=67) */

#line 67 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=2083, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=2083, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=2312, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Rx_Par_Or__OUT_81);

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or_sub_2_IN_80:;

/* Loop (n=233, ln=73) */

#line 73 "./libraries/driver-usart/avr/usart.ceu"
while (1) {
        
/* Block (n=232, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
{

/* Atomic (n=205, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
ceu_callback_isr_enable(0, CEU_TRACE(0));
/* Block (n=204, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
{

/* Set_Vec (n=194, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=194, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
    __ceu_nxt = (*((*((tceu_code_mem_USART_Rx*)_ceu_mem)).buf)).len;

/* Set_Vec (n=194, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
    __ceu_nxt = (*((*((tceu_code_mem_USART_Rx*)_ceu_mem)).buf)).len;

/* Set_Vec (n=194, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
    ceu_assert(&((CEU_APP.root.usart_rx_buf_102)) != &(*((*((tceu_code_mem_USART_Rx*)_ceu_mem)).buf)), "source is the same as destination");

/* Set_Vec (n=194, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
    ceu_vector_copy(&(*((*((tceu_code_mem_USART_Rx*)_ceu_mem)).buf)), __ceu_nxt, &((CEU_APP.root.usart_rx_buf_102)), 0, ((CEU_APP.root.usart_rx_buf_102)).len);

/* Set_Vec (n=194, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
    __ceu_nxt = (*((*((tceu_code_mem_USART_Rx*)_ceu_mem)).buf)).len;

/* Set_Vec (n=194, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
}

/* Set_Vec (n=201, ln=76) */

#line 76 "./libraries/driver-usart/avr/usart.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=201, ln=76) */

#line 76 "./libraries/driver-usart/avr/usart.ceu"
    ceu_vector_setlen(&((CEU_APP.root.usart_rx_buf_102)), 0, 0);
    __ceu_nxt = 0;

/* Set_Vec (n=201, ln=76) */

#line 76 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=204, ln=75) */

#line 75 "./libraries/driver-usart/avr/usart.ceu"
}

/* Atomic (n=205, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
ceu_callback_isr_enable(1, CEU_TRACE(0));
/* If (n=226, ln=78) */

#line 78 "./libraries/driver-usart/avr/usart.ceu"
if (((((((*((tceu_code_mem_USART_Rx*)_ceu_mem)).n)).is_set)&&(((*((*((tceu_code_mem_USART_Rx*)_ceu_mem)).buf)).len)>=(CEU_OPTION_tceu_opt_usize(&(((*((tceu_code_mem_USART_Rx*)_ceu_mem)).n)), CEU_TRACE(0))->value)))||((!((((*((tceu_code_mem_USART_Rx*)_ceu_mem)).n)).is_set))&&(((*((*((tceu_code_mem_USART_Rx*)_ceu_mem)).buf)).len)>0)))) {
    
/* Block (n=225, ln=79) */

#line 79 "./libraries/driver-usart/avr/usart.ceu"
{

/* Break (n=223, ln=79) */

#line 79 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Rx_Loop_Break__OUT_95);

/* Block (n=225, ln=79) */

#line 79 "./libraries/driver-usart/avr/usart.ceu"
}
} else {
    
/* Block (n=1310, ln=78) */

#line 78 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=1310, ln=78) */

#line 78 "./libraries/driver-usart/avr/usart.ceu"
}
}

/* Await_Ext (n=229, ln=82) */

#line 82 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].evt = ((tceu_evt){CEU_INPUT_USART_RX,{NULL}});

/* Await_Ext (n=229, ln=82) */

#line 82 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].lbl = CEU_LABEL_USART_Rx_Await_USART_RX__OUT_90;

/* Await_Ext (n=229, ln=82) */

#line 82 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Await_Ext (n=229, ln=82) */

#line 82 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Await_USART_RX__OUT_90:;

/* Block (n=232, ln=74) */

#line 74 "./libraries/driver-usart/avr/usart.ceu"
}

/* Loop (n=233, ln=73) */

#line 73 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Loop_Continue__CNT_93:;

/* Loop (n=233, ln=73) */

#line 73 "./libraries/driver-usart/avr/usart.ceu"
        *_ceu_trlK = 3;
}

/* Loop (n=233, ln=73) */

#line 73 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Loop_Break__OUT_95:;

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Rx_Par_Or__OUT_81);

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or__OUT_81:;

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Rx_Par_Or__CLR_82;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 2+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2315, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or__CLR_82:;

/* Block (n=235, ln=64) */

#line 64 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=1292, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=1294, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

/* Do (n=1295, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Do__OUT_99:;

/* Do (n=1295, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
    _ceu_mem->has_term = 1;

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Rx_Par_Or__OUT_75);

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or__OUT_75:;

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_USART_Rx_Par_Or__CLR_76;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2309, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Rx_Par_Or__CLR_76:;

/* Block (n=1303, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=1304, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Code (n=1304, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=1328, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1328, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
case CEU_LABEL_Code_INT0_Get:;

/* Block (n=1327, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Block (n=1319, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Block (n=1317, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Block (n=257, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Set_Exp (n=1329, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
(((*((tceu_code_mem_INT0_Get*)_ceu_mem))._ret)) = (((bool)((((bool)(digitalRead(2)))? 1 : 0)))? 1 : 0);

/* Escape (n=255, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
CEU_GOTO(CEU_LABEL_INT0_Get_Do__OUT_106);

/* Block (n=257, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Block (n=1317, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Block (n=1319, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Do (n=1320, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=1320, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
case CEU_LABEL_INT0_Get_Do__OUT_106:;

/* Block (n=1327, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Code (n=1328, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
return 0;

/* Code (n=1328, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Nat_Stmt (n=261, ln=11) */

#line 11 "./libraries/driver-gpio/avr/int0.ceu"

    pinMode(2, INPUT_PULLUP);
    EICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (CHANGE << ISC00);
    EIMSK |= (1 << INT0);

/* Code (n=1350, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1350, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_Code_DSensor_INT0:;

/* Block (n=1349, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_DSensor_INT0_Par_Or_sub_2_IN_114;

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
CEU_GOTO(CEU_LABEL_DSensor_INT0_Par_Or_sub_1_IN_113);

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or_sub_1_IN_113:;

/* Finalize_Case (n=2085, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[1].lbl    = CEU_LABEL_DSensor_INT0_Finalize_Case__IN_118;

/* Finalize_Case (n=2085, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
if (0) {

/* Finalize_Case (n=2085, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Finalize_Case__IN_118:;

/* Block (n=1344, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Code_Finalize (n=1342, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
if (_ceu_mem->has_term) {
    /* generate only if terminating from inside */
    _ceu_mem->_trails[1].evt.id = CEU_INPUT__STACKED;
    _ceu_mem->_trails[1].level  = _ceu_level;
    _ceu_mem->_trails[1].lbl    = CEU_LABEL_DSensor_INT0_Code_DSensor_INT0__TERM_151;

    tceu_evt   __ceu_evt   = { CEU_INPUT__CODE_TERMINATED, {_ceu_mem} };
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;

/* Code_Finalize (n=1342, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_nxt->params_n = 0;

/* Code_Finalize (n=1342, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

#ifdef CEU_FEATURES_POOL
if (_ceu_mem->pak != NULL) {
    tceu_code_mem_dyn* __ceu_dyn =
        (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));
    __ceu_dyn->is_alive = 0;
}
#endif

ceu_stack_clear(_ceu_cur, _ceu_mem);

if (_ceu_mem->has_term) {
    _ceu_mem->has_term = 0;
    return 1;
} else {
    return 0;
}

/* Code_Finalize (n=1342, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Block (n=1344, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Finalize_Case (n=2085, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Finalize_Case (n=2085, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Await_Forever (n=2318, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
CEU_GOTO(CEU_LABEL_DSensor_INT0_Par_Or__OUT_115);

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or_sub_2_IN_114:;

/* Block (n=1340, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Block (n=1338, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Block (n=366, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_DSensor_INT0_Par_Or_sub_2_IN_120;

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
CEU_GOTO(CEU_LABEL_DSensor_INT0_Par_Or_sub_1_IN_119);

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or_sub_1_IN_119:;

/* Finalize_Case (n=2087, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_DSensor_INT0_Finalize_Case__IN_126;

/* Finalize_Case (n=2087, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
if (0) {

/* Finalize_Case (n=2087, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Finalize_Case__IN_126:;

/* Block (n=299, ln=8) */

#line 8 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* If (n=297, ln=8) */

#line 8 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
if (((((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).energyPort)).is_set)) {
    
/* Block (n=296, ln=9) */

#line 9 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Stmt_Call (n=294, ln=9) */

#line 9 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
digitalWrite((CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).energyPort)), CEU_TRACE(0))->value),0);

/* Block (n=296, ln=9) */

#line 9 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
} else {
    
/* Block (n=1357, ln=8) */

#line 8 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Block (n=1357, ln=8) */

#line 8 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
}

/* Block (n=299, ln=8) */

#line 8 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Finalize_Case (n=2087, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Finalize_Case (n=2087, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Await_Forever (n=2324, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
CEU_GOTO(CEU_LABEL_DSensor_INT0_Par_Or__OUT_121);

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or_sub_2_IN_120:;

/* If (n=326, ln=13) */

#line 13 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
if (((((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).energyPort)).is_set)) {
    
/* Block (n=325, ln=15) */

#line 15 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Nat_Stmt (n=307, ln=15) */

#line 15 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"

            pinMode((CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).energyPort)), CEU_TRACE(0))->value), OUTPUT);
            digitalWrite((CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).energyPort)), CEU_TRACE(0))->value), HIGH);
        
/* If (n=323, ln=21) */

#line 21 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
if (((((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).time)).is_set)) {
    
/* Block (n=316, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Await_Wclock (n=314, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
ceu_wclock(((CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).time)), CEU_TRACE(0))->value))*1000.0, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_314), NULL, CEU_TRACE(0));

_CEU_HALT_314_:

/* Await_Wclock (n=314, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=314, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].lbl = CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_127;

/* Await_Wclock (n=314, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Await_Wclock (n=314, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_127:;

/* Await_Wclock (n=314, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_314), CEU_TRACE(0)) ) {
        goto _CEU_HALT_314_;
    }
}

/* Block (n=316, ln=22) */

#line 22 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
} else {
    
/* Block (n=322, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Await_Wclock (n=320, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
ceu_wclock((1)*1000.0, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_320), NULL, CEU_TRACE(0));

_CEU_HALT_320_:

/* Await_Wclock (n=320, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=320, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].lbl = CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_129;

/* Await_Wclock (n=320, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Await_Wclock (n=320, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_129:;

/* Await_Wclock (n=320, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_320), CEU_TRACE(0)) ) {
        goto _CEU_HALT_320_;
    }
}

/* Block (n=322, ln=24) */

#line 24 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
}

/* Block (n=325, ln=15) */

#line 15 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
} else {
    
/* Block (n=1359, ln=13) */

#line 13 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Block (n=1359, ln=13) */

#line 13 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
}

/* Loop (n=364, ln=28) */

#line 28 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
while (1) {
        
/* Block (n=363, ln=29) */

#line 29 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Await_Ext (n=329, ln=29) */

#line 29 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].evt = ((tceu_evt){CEU_INPUT_INT0,{NULL}});

/* Await_Ext (n=329, ln=29) */

#line 29 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].lbl = CEU_LABEL_DSensor_INT0_Await_INT0__OUT_133;

/* Await_Ext (n=329, ln=29) */

#line 29 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Await_Ext (n=329, ln=29) */

#line 29 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Await_INT0__OUT_133:;

/* If (n=346, ln=32) */

#line 32 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
if (((((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).debounce)).is_set)) {
    
/* Block (n=339, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Await_Wclock (n=337, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
ceu_wclock(((CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).debounce)), CEU_TRACE(0))->value))*1000.0, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_337), NULL, CEU_TRACE(0));

_CEU_HALT_337_:

/* Await_Wclock (n=337, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=337, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].lbl = CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_134;

/* Await_Wclock (n=337, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Await_Wclock (n=337, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_134:;

/* Await_Wclock (n=337, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_337), CEU_TRACE(0)) ) {
        goto _CEU_HALT_337_;
    }
}

/* Block (n=339, ln=33) */

#line 33 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
} else {
    
/* Block (n=345, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{

/* Await_Wclock (n=343, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
ceu_wclock((500)*1000.0, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_343), NULL, CEU_TRACE(0));

_CEU_HALT_343_:

/* Await_Wclock (n=343, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=343, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].lbl = CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_136;

/* Await_Wclock (n=343, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Await_Wclock (n=343, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Await_Wclock__OUT_136:;

/* Await_Wclock (n=343, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).__wclk_343), CEU_TRACE(0)) ) {
        goto _CEU_HALT_343_;
    }
}

/* Block (n=345, ln=35) */

#line 35 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}
}

/* Set_Exp (n=353, ln=38) */

#line 38 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
(((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).v_354)) = CEU_CODE_INT0_Get(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_INT0_Get __ceu_351;; __ceu_351;})

#else
(tceu_code_mem_INT0_Get) {  }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Emit_Evt (n=361, ln=43) */

#line 43 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_DSensor_INT0_Emit_Int__OUT_138;
{
    tceu_evt   __ceu_evt   = ((tceu_evt){CEU_EVENT_CHANGE_283,{_ceu_mem}});
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt     = __ceu_evt;
    _ceu_nxt->range   = __ceu_range;

/* Emit_Evt (n=361, ln=43) */

#line 43 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
{
    tceu_event___lpar__bool__rpar__ __ceu_ps = { (((*((tceu_code_mem_DSensor_INT0*)_ceu_mem)).v_354)) };
    ceu_params_cpy(_ceu_nxt, &__ceu_ps, sizeof(__ceu_ps));
}

/* Emit_Evt (n=361, ln=43) */

#line 43 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
    return 1;
}

/* Emit_Evt (n=361, ln=43) */

#line 43 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Emit_Int__OUT_138:;

/* Block (n=363, ln=29) */

#line 29 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Loop (n=364, ln=28) */

#line 28 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Loop_Continue__CNT_141:;

/* Loop (n=364, ln=28) */

#line 28 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
        *_ceu_trlK = 3;
}

/* Loop (n=364, ln=28) */

#line 28 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Loop_Break__OUT_143:;

/* Nat_Stmt (n=1764, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
ceu_assert(0, "reached end of `code`");
/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
CEU_GOTO(CEU_LABEL_DSensor_INT0_Par_Or__OUT_121);

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or__OUT_121:;

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_DSensor_INT0_Par_Or__CLR_122;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 2+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2327, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or__CLR_122:;

/* Block (n=366, ln=7) */

#line 7 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Block (n=1338, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Block (n=1340, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Do (n=1341, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Do__OUT_147:;

/* Do (n=1341, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
    _ceu_mem->has_term = 1;

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
CEU_GOTO(CEU_LABEL_DSensor_INT0_Par_Or__OUT_115);

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or__OUT_115:;

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_DSensor_INT0_Par_Or__CLR_116;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2321, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
case CEU_LABEL_DSensor_INT0_Par_Or__CLR_116:;

/* Block (n=1349, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Code (n=1350, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
return 0;

/* Code (n=1350, ln=6) */

#line 6 "./libraries/driver-dsensor/avr/dsensor-int0.ceu"
}

/* Code (n=1542, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1542, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Check:;

/* Block (n=1541, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1537, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1535, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=428, ln=75) */

#line 75 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=394, ln=75) */

#line 75 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert((((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).max)>0),"dynamic vector is not supported");

/* If (n=426, ln=76) */

#line 76 "/home/anny/dev/ceu/include/string.ceu"
if ((((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len)>0)) {
    
/* Block (n=413, ln=77) */

#line 77 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=411, ln=77) */

#line 77 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(((*(byte*) ceu_vector_geti((((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)),(((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len)-1)))
==('\0')),"invalid string");

/* Block (n=413, ln=77) */

#line 77 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=425, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Vec (n=422, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=422, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    __ceu_nxt = (*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len;

/* Set_Vec (n=422, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    __ceu_nxt = (*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len;

/* Set_Vec (n=422, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    ceu_vector_setlen(&(*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)), ((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len + 1), 1);

/* Set_Vec (n=422, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    *((byte*)
        ceu_vector_buf_get(&(*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)), __ceu_nxt++)) = ('\0');

/* Set_Vec (n=422, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"

/* Set_Vec (n=422, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=425, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Block (n=428, ln=75) */

#line 75 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1535, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1537, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1538, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Check_Do__OUT_157:;

/* Block (n=1541, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1542, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1542, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1556, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1556, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Print:;

/* Block (n=1555, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1551, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1549, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=447, ln=84) */

#line 84 "/home/anny/dev/ceu/include/string.ceu"
{

/* Nat_Stmt (n=445, ln=84) */

#line 84 "/home/anny/dev/ceu/include/string.ceu"

        const char* strC = ((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Print*)_ceu_mem)).str)),0))
)));
        printf("%s", strC);
    
/* Block (n=447, ln=84) */

#line 84 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1549, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1551, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1552, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Print_Do__OUT_165:;

/* Block (n=1555, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1556, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1556, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1570, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1570, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Append_STR:;

/* Block (n=1569, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1565, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1563, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=505, ln=91) */

#line 91 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=466, ln=91) */

#line 91 "/home/anny/dev/ceu/include/string.ceu"
CEU_CODE_String_Check(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Check __ceu_464;__ceu_464.dst = ((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)));; __ceu_464;})

#else
(tceu_code_mem_String_Check) { .dst = ((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst))) }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Stmt_Call (n=489, ln=92) */

#line 92 "/home/anny/dev/ceu/include/string.ceu"
strncat(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)),0))
))),((char*)((&((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).src))[0])))),(((*((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)).max)-((*((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)).len)));

/* Stmt_Call (n=503, ln=93) */

#line 93 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst))),(((*((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)).len)+strlen((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).src)))),1);

/* Block (n=505, ln=91) */

#line 91 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1563, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1565, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1566, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Append_STR_Do__OUT_173:;

/* Block (n=1569, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1570, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1570, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1585, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1585, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Append_INT:;

/* Block (n=1584, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1580, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1578, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=591, ln=97) */

#line 97 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=527, ln=97) */

#line 97 "/home/anny/dev/ceu/include/string.ceu"
CEU_CODE_String_Check(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Check __ceu_525;__ceu_525.dst = ((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)));; __ceu_525;})

#else
(tceu_code_mem_String_Check) { .dst = ((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst))) }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Set_Exp (n=535, ln=99) */

#line 99 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(&(*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)),(((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)-1), 0);

/* If (n=547, ln=101) */

#line 101 "/home/anny/dev/ceu/include/string.ceu"
if ((!((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)).is_set))) {
    
/* Block (n=546, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=543, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)).is_set = 1;

/* Set_Exp (n=543, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)).value) = 10;

/* Block (n=546, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=1590, ln=101) */

#line 101 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1590, ln=101) */

#line 101 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Set_Exp (n=569, ln=105) */

#line 105 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).n)) = ceu_itona((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).src)),((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)),((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)))
))),(CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)), CEU_TRACE(0))->value),(((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).max)-((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)));

/* Stmt_Call (n=578, ln=106) */

#line 106 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).n))>0),"access out of bounds");

/* Stmt_Call (n=589, ln=107) */

#line 107 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst))),(((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)+(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).n))),1);

/* Block (n=591, ln=97) */

#line 97 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1578, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1580, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1581, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Append_INT_Do__OUT_183:;

/* Block (n=1584, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1585, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1585, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1607, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1607, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Append_REAL:;

/* Block (n=1606, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1602, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1600, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=671, ln=111) */

#line 111 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=613, ln=111) */

#line 111 "/home/anny/dev/ceu/include/string.ceu"
CEU_CODE_String_Check(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Check __ceu_611;__ceu_611.dst = ((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)));; __ceu_611;})

#else
(tceu_code_mem_String_Check) { .dst = ((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst))) }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* If (n=624, ln=113) */

#line 113 "/home/anny/dev/ceu/include/string.ceu"
if ((!((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)).is_set))) {
    
/* Block (n=623, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=620, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)).is_set = 1;

/* Set_Exp (n=620, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)).value) = 2;

/* Block (n=623, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=1612, ln=113) */

#line 113 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1612, ln=113) */

#line 113 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Stmt_Call (n=633, ln=117) */

#line 117 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(((CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)), CEU_TRACE(0))->value)<999),"precision error");

/* Nat_Stmt (n=636, ln=119) */

#line 119 "/home/anny/dev/ceu/include/string.ceu"

        char format[6];
        sprintf(format, "%%.%df", (CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)), CEU_TRACE(0))->value));
    
/* Stmt_Call (n=649, ln=124) */

#line 124 "/home/anny/dev/ceu/include/string.ceu"
sprintf(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)),0))
))),(format),(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).src)));

/* Stmt_Call (n=669, ln=126) */

#line 126 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst))),(((*((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)).len)+strlen(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)),0))
))))),1);

/* Block (n=671, ln=111) */

#line 111 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1600, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1602, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1603, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Append_REAL_Do__OUT_193:;

/* Block (n=1606, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1607, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1607, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1629, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1629, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Equal:;

/* Block (n=1628, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1620, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1618, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=718, ln=132) */

#line 132 "/home/anny/dev/ceu/include/string.ceu"
{

/* Nat_Stmt (n=704, ln=133) */

#line 133 "/home/anny/dev/ceu/include/string.ceu"

        (((*((tceu_code_mem_String_Equal*)_ceu_mem)).result))= strcmp(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Equal*)_ceu_mem)).str1)),0))
))), ((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Equal*)_ceu_mem)).str2)),0))
))));
    
/* If (n=716, ln=137) */

#line 137 "/home/anny/dev/ceu/include/string.ceu"
if (((((*((tceu_code_mem_String_Equal*)_ceu_mem)).result))==0)) {
    
/* Block (n=711, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1636, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal*)_ceu_mem))._ret)) = 1;

/* Escape (n=709, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_Do__OUT_203);

/* Block (n=711, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=715, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1637, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal*)_ceu_mem))._ret)) = 0;

/* Escape (n=713, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_Do__OUT_203);

/* Block (n=715, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Block (n=718, ln=132) */

#line 132 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1618, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1620, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1621, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=1621, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Equal_Do__OUT_203:;

/* Block (n=1628, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1629, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1629, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1654, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1654, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Equal_STR:;

/* Block (n=1653, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1645, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1643, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=765, ln=145) */

#line 145 "/home/anny/dev/ceu/include/string.ceu"
{

/* Nat_Stmt (n=751, ln=146) */

#line 146 "/home/anny/dev/ceu/include/string.ceu"

        (((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).result))= strcmp(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).str1)),0))
))), ((char*)((&((((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).str2))[0])))));
    
/* If (n=763, ln=150) */

#line 150 "/home/anny/dev/ceu/include/string.ceu"
if (((((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).result))==0)) {
    
/* Block (n=758, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1661, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal_STR*)_ceu_mem))._ret)) = 1;

/* Escape (n=756, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_STR_Do__OUT_213);

/* Block (n=758, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=762, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1662, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal_STR*)_ceu_mem))._ret)) = 0;

/* Escape (n=760, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_STR_Do__OUT_213);

/* Block (n=762, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Block (n=765, ln=145) */

#line 145 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1643, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1645, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1646, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=1646, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Equal_STR_Do__OUT_213:;

/* Block (n=1653, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1654, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1654, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_Par_Or_sub_2_IN_219;

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or_sub_1_IN_218);

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_1_IN_218:;

/* Abs_Spawn (n=775, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__PROPAGATE_CODE;

/* Abs_Spawn (n=775, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[1].evt.mem = (tceu_code_mem*) &(CEU_APP.root.__mem_775);

/* Abs_Spawn (n=775, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[1].lbl = CEU_LABEL_Await_Spawn__OUT_222;

/* Abs_Spawn (n=775, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
{
    *((tceu_code_mem_USART_Init*)(&(CEU_APP.root. __mem_775))) = 
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_USART_Init __ceu_774;__ceu_774.bps = 9600;; __ceu_774;})

#else
(tceu_code_mem_USART_Init) { .bps = 9600 }

#endif
;
#ifdef CEU_FEATURES_POOL
    (&(CEU_APP.root. __mem_775))->_mem.pak    = NULL;
#endif
    (&(CEU_APP.root. __mem_775))->_mem.up_mem = _ceu_mem;
    (&(CEU_APP.root. __mem_775))->_mem.depth  = 0;
    (&(CEU_APP.root. __mem_775))->_mem.has_term = 0;
    (&(CEU_APP.root. __mem_775))->_mem.trails_n = 5;
    memset(&(&(CEU_APP.root. __mem_775))->_mem._trails, 0, 5*sizeof(tceu_trl));
    (&(CEU_APP.root. __mem_775))->_mem._trails[0].evt.id = CEU_INPUT__STACKED;
    (&(CEU_APP.root. __mem_775))->_mem._trails[0].level  = _ceu_level+1;
    (&(CEU_APP.root. __mem_775))->_mem._trails[0].lbl    = CEU_CODE_USART_Init_to_lbl((&(CEU_APP.root. __mem_775)));
}

{
    tceu_evt   __ceu_evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range __ceu_range = { (tceu_code_mem*)(&(CEU_APP.root. __mem_775)), 0, 5-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    //return 1; (later, after deciding for spawn/await)
}

/* Abs_Spawn (n=775, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
return 1;

/* Abs_Spawn (n=775, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_Spawn__OUT_222:;

/* Await_Forever (n=2330, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
return 0;

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_220);

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_2_IN_219:;

/* Loop (n=895, ln=11) */

#line 11 "libraries/driver-gpio/examples/out-01.ceu"
while (1) {
        
/* Block (n=894, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[5].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[5].level  = _ceu_level;
_ceu_mem->_trails[5].lbl    = CEU_LABEL_Par_Or_sub_2_IN_224;

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or_sub_1_IN_223);

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_1_IN_223:;

/* Block (n=812, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Loop (n=810, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
while (1) {
        
/* Block (n=809, ln=14) */

#line 14 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Vec_Init (n=2020, ln=14) */

#line 14 "libraries/driver-gpio/examples/out-01.ceu"
ceu_vector_init(&((CEU_APP.root.str_783)),2, 0, 0, sizeof(byte),
                (byte*)&((CEU_APP.root.str_783_buf)));

/* Set_Vec (n=782, ln=14) */

#line 14 "libraries/driver-gpio/examples/out-01.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=782, ln=14) */

#line 14 "libraries/driver-gpio/examples/out-01.ceu"
    ceu_vector_setlen(&((CEU_APP.root.str_783)), 0, 0);
    __ceu_nxt = 0;

/* Set_Vec (n=782, ln=14) */

#line 14 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Abs_Await (n=791, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__PROPAGATE_CODE;

/* Abs_Await (n=791, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[4].evt.mem = (tceu_code_mem*) &(CEU_APP.root.__mem_791);

/* Abs_Await (n=791, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[4].lbl = CEU_LABEL_Await_Await__OUT_227;

/* Abs_Await (n=791, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
{
    *((tceu_code_mem_USART_Rx*)(&(CEU_APP.root. __mem_791))) = 
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_USART_Rx __ceu_789;__ceu_789.buf = (&((CEU_APP.root.str_783)));__ceu_789.n = { .is_set=0 };; __ceu_789;})

#else
(tceu_code_mem_USART_Rx) { .buf = (&((CEU_APP.root.str_783))),.n = { .is_set=0 } }

#endif
;
#ifdef CEU_FEATURES_POOL
    (&(CEU_APP.root. __mem_791))->_mem.pak    = NULL;
#endif
    (&(CEU_APP.root. __mem_791))->_mem.up_mem = _ceu_mem;
    (&(CEU_APP.root. __mem_791))->_mem.depth  = 0;
    (&(CEU_APP.root. __mem_791))->_mem.has_term = 0;
    (&(CEU_APP.root. __mem_791))->_mem.trails_n = 5;
    memset(&(&(CEU_APP.root. __mem_791))->_mem._trails, 0, 5*sizeof(tceu_trl));
    (&(CEU_APP.root. __mem_791))->_mem._trails[0].evt.id = CEU_INPUT__STACKED;
    (&(CEU_APP.root. __mem_791))->_mem._trails[0].level  = _ceu_level+1;
    (&(CEU_APP.root. __mem_791))->_mem._trails[0].lbl    = CEU_CODE_USART_Rx_to_lbl((&(CEU_APP.root. __mem_791)));
}

{
    tceu_evt   __ceu_evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range __ceu_range = { (tceu_code_mem*)(&(CEU_APP.root. __mem_791)), 0, 5-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    //return 1; (later, after deciding for spawn/await)
}

/* Abs_Await (n=791, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
return 1;

/* Abs_Await (n=791, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_Await__OUT_227:;

/* If (n=807, ln=16) */

#line 16 "libraries/driver-gpio/examples/out-01.ceu"
if (CEU_CODE_String_Equal_STR(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Equal_STR __ceu_797;__ceu_797.str1 = (&((CEU_APP.root.str_783)));__ceu_797.str2 = "1";; __ceu_797;})

#else
(tceu_code_mem_String_Equal_STR) { .str1 = (&((CEU_APP.root.str_783))),.str2 = "1" }

#endif
,((tceu_code_mem*)_ceu_mem))
) {
    
/* Block (n=806, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Emit_Ext_emit (n=803, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Emit_Ext_emit (n=803, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=803, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
__ceu_ps._1 = 1;

/* Emit_Ext_emit (n=803, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=803, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Break (n=804, ln=18) */

#line 18 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Loop_Break__OUT_235);

/* Block (n=806, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
}
} else {
    
/* Block (n=1669, ln=16) */

#line 16 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Block (n=1669, ln=16) */

#line 16 "libraries/driver-gpio/examples/out-01.ceu"
}
}

/* Block (n=809, ln=14) */

#line 14 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Loop (n=810, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_233:;

/* Loop (n=810, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
        *_ceu_trlK = 3;
}

/* Loop (n=810, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Break__OUT_235:;

/* Block (n=812, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_225);

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_2_IN_224:;

/* Block (n=857, ln=22) */

#line 22 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Loop (n=855, ln=22) */

#line 22 "libraries/driver-gpio/examples/out-01.ceu"
while (1) {
        
/* Block (n=854, ln=23) */

#line 23 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Block (n=838, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[8].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[8].level  = _ceu_level;
_ceu_mem->_trails[8].lbl    = CEU_LABEL_Par_Or_sub_2_IN_238;

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or_sub_1_IN_237);

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_1_IN_237:;

/* Abs_Spawn (n=821, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
((CEU_APP.root.mysensor_823)) = &(CEU_APP.root.__mem_821);
_ceu_mem->_trails[6].evt.mem =  &(CEU_APP.root.__mem_821);

/* Abs_Spawn (n=821, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[7].evt.id = CEU_INPUT__PROPAGATE_CODE;

/* Abs_Spawn (n=821, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[7].evt.mem = (tceu_code_mem*) &(CEU_APP.root.__mem_821);

/* Abs_Spawn (n=821, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[7].lbl = CEU_LABEL_Await_Spawn__OUT_241;

/* Abs_Spawn (n=821, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
{
    *((tceu_code_mem_DSensor_INT0*)(&(CEU_APP.root. __mem_821))) = 
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_DSensor_INT0 __ceu_820;__ceu_820.energyPort = { .is_set=1, .value=7};__ceu_820.time = { .is_set=0 };__ceu_820.debounce = { .is_set=1, .value=0};; __ceu_820;})

#else
(tceu_code_mem_DSensor_INT0) { .energyPort = { .is_set=1, .value=7},.time = { .is_set=0 },.debounce = { .is_set=1, .value=0} }

#endif
;
#ifdef CEU_FEATURES_POOL
    (&(CEU_APP.root. __mem_821))->_mem.pak    = NULL;
#endif
    (&(CEU_APP.root. __mem_821))->_mem.up_mem = _ceu_mem;
    (&(CEU_APP.root. __mem_821))->_mem.depth  = 0;
    (&(CEU_APP.root. __mem_821))->_mem.has_term = 0;
    (&(CEU_APP.root. __mem_821))->_mem.trails_n = 5;
    memset(&(&(CEU_APP.root. __mem_821))->_mem._trails, 0, 5*sizeof(tceu_trl));
    (&(CEU_APP.root. __mem_821))->_mem._trails[0].evt.id = CEU_INPUT__STACKED;
    (&(CEU_APP.root. __mem_821))->_mem._trails[0].level  = _ceu_level+1;
    (&(CEU_APP.root. __mem_821))->_mem._trails[0].lbl    = CEU_CODE_DSensor_INT0_to_lbl((&(CEU_APP.root. __mem_821)));
}

{
    tceu_evt   __ceu_evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range __ceu_range = { (tceu_code_mem*)(&(CEU_APP.root. __mem_821)), 0, 5-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    //return 1; (later, after deciding for spawn/await)
}

/* Abs_Spawn (n=821, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
return 1;

/* Abs_Spawn (n=821, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_Spawn__OUT_241:;

/* Await_Forever (n=2336, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
return 0;

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_239);

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_2_IN_238:;

/* Await_Until (n=834, ln=25) */

#line 25 "libraries/driver-gpio/examples/out-01.ceu"
do {

/* Await_Int (n=830, ln=25) */

#line 25 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[8].evt = ((tceu_evt){ CEU_EVENT_CHANGE_283, {&(*(CEU_APP.root.mysensor_823))} });

/* Await_Int (n=830, ln=25) */

#line 25 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[8].lbl = CEU_LABEL_Await_change__OUT_242;

/* Await_Int (n=830, ln=25) */

#line 25 "libraries/driver-gpio/examples/out-01.ceu"
return 0;

/* Await_Int (n=830, ln=25) */

#line 25 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_change__OUT_242:;

/* Set_Await_Int (n=835, ln=25) */

#line 25 "libraries/driver-gpio/examples/out-01.ceu"
((CEU_APP.root.v_836)) = ((tceu_event___lpar__bool__rpar__*)(_ceu_cur->params))->_1;

/* Await_Until (n=834, ln=25) */

#line 25 "libraries/driver-gpio/examples/out-01.ceu"
} while (!(((CEU_APP.root.v_836))==1));

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_239);

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__OUT_239:;

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[6].level  = _ceu_level;
_ceu_mem->_trails[6].lbl    = CEU_LABEL_Par_Or__CLR_240;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 6+1, 8 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2339, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__CLR_240:;

/* Block (n=838, ln=24) */

#line 24 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Do (n=839, ln=23) */

#line 23 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Do__OUT_244:;

/* Emit_Ext_emit (n=844, ln=28) */

#line 28 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Emit_Ext_emit (n=844, ln=28) */

#line 28 "libraries/driver-gpio/examples/out-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=844, ln=28) */

#line 28 "libraries/driver-gpio/examples/out-01.ceu"
__ceu_ps._1 = 1;

/* Emit_Ext_emit (n=844, ln=28) */

#line 28 "libraries/driver-gpio/examples/out-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=844, ln=28) */

#line 28 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Await_Wclock (n=847, ln=29) */

#line 29 "libraries/driver-gpio/examples/out-01.ceu"
ceu_wclock(3000000.0, &(CEU_APP.root.__wclk_847), NULL, CEU_TRACE(0));

_CEU_HALT_847_:

/* Await_Wclock (n=847, ln=29) */

#line 29 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__WCLOCK;

/* Await_Wclock (n=847, ln=29) */

#line 29 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[6].lbl = CEU_LABEL_Await_Wclock__OUT_247;

/* Await_Wclock (n=847, ln=29) */

#line 29 "libraries/driver-gpio/examples/out-01.ceu"
return 0;

/* Await_Wclock (n=847, ln=29) */

#line 29 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_Wclock__OUT_247:;

/* Await_Wclock (n=847, ln=29) */

#line 29 "libraries/driver-gpio/examples/out-01.ceu"
/* subtract time and check if I have to awake */
{
    s32* dt = (s32*)_ceu_cur->params;
    if (!ceu_wclock(*dt, NULL, &(CEU_APP.root.__wclk_847), CEU_TRACE(0)) ) {
        goto _CEU_HALT_847_;
    }
}

/* Emit_Ext_emit (n=852, ln=30) */

#line 30 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Emit_Ext_emit (n=852, ln=30) */

#line 30 "libraries/driver-gpio/examples/out-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=852, ln=30) */

#line 30 "libraries/driver-gpio/examples/out-01.ceu"
__ceu_ps._1 = 0;

/* Emit_Ext_emit (n=852, ln=30) */

#line 30 "libraries/driver-gpio/examples/out-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=852, ln=30) */

#line 30 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Block (n=854, ln=23) */

#line 23 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Loop (n=855, ln=22) */

#line 22 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_251:;

/* Loop (n=855, ln=22) */

#line 22 "libraries/driver-gpio/examples/out-01.ceu"
        *_ceu_trlK = 4;
}

/* Loop (n=855, ln=22) */

#line 22 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Break__OUT_253:;

/* Block (n=857, ln=22) */

#line 22 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_225);

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__OUT_225:;

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[3].level  = _ceu_level;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_Par_Or__CLR_226;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 3+1, 8 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=858, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__CLR_226:;

/* Loop (n=892, ln=34) */

#line 34 "libraries/driver-gpio/examples/out-01.ceu"
while (1) {
        
/* Block (n=891, ln=35) */

#line 35 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Vec_Init (n=2057, ln=35) */

#line 35 "libraries/driver-gpio/examples/out-01.ceu"
ceu_vector_init(&((CEU_APP.root.str_865)),2, 0, 0, sizeof(byte),
                (byte*)&((CEU_APP.root.str_865_buf)));

/* Set_Vec (n=864, ln=35) */

#line 35 "libraries/driver-gpio/examples/out-01.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=864, ln=35) */

#line 35 "libraries/driver-gpio/examples/out-01.ceu"
    ceu_vector_setlen(&((CEU_APP.root.str_865)), 0, 0);
    __ceu_nxt = 0;

/* Set_Vec (n=864, ln=35) */

#line 35 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Abs_Await (n=873, ln=36) */

#line 36 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__PROPAGATE_CODE;

/* Abs_Await (n=873, ln=36) */

#line 36 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].evt.mem = (tceu_code_mem*) &(CEU_APP.root.__mem_873);

/* Abs_Await (n=873, ln=36) */

#line 36 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].lbl = CEU_LABEL_Await_Await__OUT_255;

/* Abs_Await (n=873, ln=36) */

#line 36 "libraries/driver-gpio/examples/out-01.ceu"
{
    *((tceu_code_mem_USART_Rx*)(&(CEU_APP.root. __mem_873))) = 
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_USART_Rx __ceu_871;__ceu_871.buf = (&((CEU_APP.root.str_865)));__ceu_871.n = { .is_set=0 };; __ceu_871;})

#else
(tceu_code_mem_USART_Rx) { .buf = (&((CEU_APP.root.str_865))),.n = { .is_set=0 } }

#endif
;
#ifdef CEU_FEATURES_POOL
    (&(CEU_APP.root. __mem_873))->_mem.pak    = NULL;
#endif
    (&(CEU_APP.root. __mem_873))->_mem.up_mem = _ceu_mem;
    (&(CEU_APP.root. __mem_873))->_mem.depth  = 0;
    (&(CEU_APP.root. __mem_873))->_mem.has_term = 0;
    (&(CEU_APP.root. __mem_873))->_mem.trails_n = 5;
    memset(&(&(CEU_APP.root. __mem_873))->_mem._trails, 0, 5*sizeof(tceu_trl));
    (&(CEU_APP.root. __mem_873))->_mem._trails[0].evt.id = CEU_INPUT__STACKED;
    (&(CEU_APP.root. __mem_873))->_mem._trails[0].level  = _ceu_level+1;
    (&(CEU_APP.root. __mem_873))->_mem._trails[0].lbl    = CEU_CODE_USART_Rx_to_lbl((&(CEU_APP.root. __mem_873)));
}

{
    tceu_evt   __ceu_evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range __ceu_range = { (tceu_code_mem*)(&(CEU_APP.root. __mem_873)), 0, 5-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    //return 1; (later, after deciding for spawn/await)
}

/* Abs_Await (n=873, ln=36) */

#line 36 "libraries/driver-gpio/examples/out-01.ceu"
return 1;

/* Abs_Await (n=873, ln=36) */

#line 36 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_Await__OUT_255:;

/* If (n=889, ln=37) */

#line 37 "libraries/driver-gpio/examples/out-01.ceu"
if (CEU_CODE_String_Equal_STR(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Equal_STR __ceu_879;__ceu_879.str1 = (&((CEU_APP.root.str_865)));__ceu_879.str2 = "0";; __ceu_879;})

#else
(tceu_code_mem_String_Equal_STR) { .str1 = (&((CEU_APP.root.str_865))),.str2 = "0" }

#endif
,((tceu_code_mem*)_ceu_mem))
) {
    
/* Block (n=888, ln=38) */

#line 38 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Emit_Ext_emit (n=885, ln=38) */

#line 38 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Emit_Ext_emit (n=885, ln=38) */

#line 38 "libraries/driver-gpio/examples/out-01.ceu"
tceu_output_OUT_13 __ceu_ps;

/* Emit_Ext_emit (n=885, ln=38) */

#line 38 "libraries/driver-gpio/examples/out-01.ceu"
__ceu_ps._1 = 0;

/* Emit_Ext_emit (n=885, ln=38) */

#line 38 "libraries/driver-gpio/examples/out-01.ceu"

#ifdef ceu_callback_output_OUT_13
ceu_callback_output_OUT_13(&__ceu_ps, CEU_TRACE(-2));
#else
1;
#endif

/* Emit_Ext_emit (n=885, ln=38) */

#line 38 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Break (n=886, ln=39) */

#line 39 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Loop_Break__OUT_263);

/* Block (n=888, ln=38) */

#line 38 "libraries/driver-gpio/examples/out-01.ceu"
}
} else {
    
/* Block (n=1684, ln=37) */

#line 37 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Block (n=1684, ln=37) */

#line 37 "libraries/driver-gpio/examples/out-01.ceu"
}
}

/* Block (n=891, ln=35) */

#line 35 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Loop (n=892, ln=34) */

#line 34 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_261:;

/* Loop (n=892, ln=34) */

#line 34 "libraries/driver-gpio/examples/out-01.ceu"
        *_ceu_trlK = 2;
}

/* Loop (n=892, ln=34) */

#line 34 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Break__OUT_263:;

/* Block (n=894, ln=12) */

#line 12 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Loop (n=895, ln=11) */

#line 11 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_266:;

/* Loop (n=895, ln=11) */

#line 11 "libraries/driver-gpio/examples/out-01.ceu"
        *_ceu_trlK = 1;
}

/* Loop (n=895, ln=11) */

#line 11 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Break__OUT_268:;

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_220);

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__OUT_220:;

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_Par_Or__CLR_221;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 8 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=2333, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__CLR_221:;

/* Block (n=934, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Do (n=935, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=935, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Do__OUT_270:;

/* Block (n=939, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
}

    }
    //ceu_assert(0, "unreachable code");
    return 0;
#undef CEU_TRACE
}

#if defined(_CEU_DEBUG)
#define _CEU_DEBUG
static int xxx = 0;
#endif

static void ceu_bcast_mark (tceu_nstk level, tceu_stk* cur)
{
    tceu_ntrl trlK = cur->range.trl0;

    for (; trlK<=cur->range.trlF; trlK++)
    {
        tceu_trl* trl = &cur->range.mem->_trails[trlK];

        //printf(">>> mark [%d/%p] evt=%d\n", trlK, trl, trl->evt.id);
#ifdef CEU_TESTS
        _ceu_tests_trails_visited_++;
#endif
        switch (trl->evt.id)
        {
#ifdef CEU_FEATURES_POOL
            case CEU_INPUT__PROPAGATE_POOL: {
                tceu_code_mem_dyn* v = trl->evt.pak->first.nxt;
                while (v != &trl->evt.pak->first) {
                    tceu_range range_ = { &v->mem[0],
                                          0, (tceu_ntrl)((&v->mem[0])->trails_n-1) };
                    tceu_stk cur_ = *cur;
                    cur_.range = range_;
                    ceu_bcast_mark(level, &cur_);
                    v = v->nxt;
                }
                break;
            }
#endif

#ifdef CEU_FEATURES_PAUSE
            case CEU_INPUT__PAUSE_BLOCK: {
                u8 was_paused = trl->pse_paused;
                if ( (cur->evt.id == trl->pse_evt.id)                               &&
                     (cur->evt.id<CEU_EVENT__MIN || cur->evt.mem==trl->pse_evt.mem) &&
                     (*((u8*)cur->params) != trl->pse_paused) )
                {
                    trl->pse_paused = *((u8*)cur->params);

                    tceu_evt evt_;
                    tceu_range range_ = { cur->range.mem,
                                          (tceu_ntrl)(trlK+1), (tceu_ntrl)(trlK+trl->pse_skip) };
                    if (trl->pse_paused) {
                        evt_.id = CEU_INPUT__PAUSE;
                    } else {
                        CEU_APP.wclk_min_set = 0;   /* maybe resuming a timer, let it be the minimum set */
                        evt_.id = CEU_INPUT__RESUME;
                    }
                    tceu_stk cur_ = { evt_, range_, NULL, 0 };
                    ceu_bcast_mark(level, &cur_);
                }
                /* don't skip if pausing now */
                if (was_paused && cur->evt.id!=CEU_INPUT__CLEAR) {
                                  /* also don't skip on CLEAR (going reverse) */
                    trlK += trl->pse_skip;
                }
                break;
            }
#endif

            case CEU_INPUT__PROPAGATE_CODE: {
#if 0
                // TODO: simple optimization that could be done
                //          - do it also for POOL?
                if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && occ->params==trl->evt.mem ) {
                    // dont propagate when I am terminating
                } else
#endif
                tceu_range range_ = {
                    (tceu_code_mem*)trl->evt.mem,
                    0,
                    (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1)
                };
                tceu_stk cur_ = *cur;
                cur_.range = range_;
                ceu_bcast_mark(level, &cur_);
                //break;    (may awake from CODE_TERMINATED)
            }

            default: {
                if (cur->evt.id == CEU_INPUT__CLEAR) {
                    if (trl->evt.id == CEU_INPUT__FINALIZE) {
//printf("AWK %d %d\n", trlK, trl->lbl);
                        goto _CEU_AWAKE_YES_;
                    }
                } else if (cur->evt.id==CEU_INPUT__CODE_TERMINATED && trl->evt.id==CEU_INPUT__PROPAGATE_CODE) {
//printf("TERM %d %d\n", trlK, trl->lbl);
                    if (trl->evt.mem == cur->evt.mem) {
                        goto _CEU_AWAKE_YES_;
                    }
                } else if (trl->evt.id == cur->evt.id) {
#ifdef CEU_FEATURES_PAUSE
                    if (cur->evt.id==CEU_INPUT__PAUSE || cur->evt.id==CEU_INPUT__RESUME) {
                        goto _CEU_AWAKE_YES_;
                    }
#endif
                    if (trl->evt.id>CEU_EVENT__MIN || trl->evt.id==CEU_INPUT__CODE_TERMINATED) {
                        if (trl->evt.mem == cur->evt.mem) {
                            goto _CEU_AWAKE_YES_;   /* internal event matches "mem" */
                        }
                    } else {
                        if (cur->evt.id != CEU_INPUT__NONE) {
                            goto _CEU_AWAKE_YES_;       /* external event matches */
                        }
                    }
                }

                continue;

_CEU_AWAKE_YES_:
                trl->evt.id = CEU_INPUT__STACKED;
                trl->level  = level;
            }
        }
    }
}

static int ceu_bcast_exec (tceu_nstk level, tceu_stk* cur, tceu_stk* nxt)
{
    /* CLEAR: inverse execution order */
    tceu_ntrl trl0 = cur->range.trl0;
    tceu_ntrl trlF = cur->range.trlF;
    if (trl0 > trlF) {
        return 0;
    }
    if (cur->evt.id == CEU_INPUT__CLEAR) {
        tceu_ntrl tmp = trl0;
        trl0 = trlF;
        trlF = tmp;
    }

    tceu_ntrl trlK = trl0;

    //printf(">>> exec %d -> %d\n", trl0, trlF);
    while (1)
    {
        tceu_trl* trl = &cur->range.mem->_trails[trlK];

        //printf(">>> exec [%d/%p] evt=%d\n", trlK, trl, trl->evt.id);
        switch (trl->evt.id)
        {
            case CEU_INPUT__PROPAGATE_CODE: {
#if 0
                // TODO: simple optimization that could be done
                //          - do it also for POOL?
                if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && occ->params==trl->evt.mem ) {
                    // dont propagate when I am terminating
                } else
#endif
                {
                    tceu_range range_ = {
                        (tceu_code_mem*)trl->evt.mem,
                        0,
                        (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1)
                    };
                    tceu_stk cur_ = *cur;
                    cur_.range = range_;
                    if (ceu_bcast_exec(level, &cur_, nxt)) {
                        return 1;
                    }
                }
                break;
            }

#ifdef CEU_FEATURES_POOL
            case CEU_INPUT__PROPAGATE_POOL: {
                ceu_assert_ex(trl->evt.pak->n_traversing < 255, "bug found", CEU_TRACE_null);
                trl->evt.pak->n_traversing++;
                tceu_code_mem_dyn* v = trl->evt.pak->first.nxt;
                while (v != &trl->evt.pak->first) {
                    if (v->is_alive) {
                        tceu_range range_ = { &v->mem[0],
                                              0, (tceu_ntrl)((&v->mem[0])->trails_n-1) };
                        tceu_stk cur_ = *cur;
                        cur_.range = range_;
                        if (ceu_bcast_exec(level, &cur_, nxt)) {
                            trl->evt.pak->n_traversing--;
                            return 1;
                        }
                    }
                    v = v->nxt;
                }
                trl->evt.pak->n_traversing--;
                ceu_code_mem_dyn_gc(trl->evt.pak);
                break;
            }
#endif

            case CEU_INPUT__STACKED: {
                if (trl->evt.id==CEU_INPUT__STACKED && trl->level==level) {
                    trl->evt.id = CEU_INPUT__NONE;
//printf("STK = %d\n", trlK);
                    if (ceu_lbl(level, cur, nxt, cur->range.mem, trl->lbl, &trlK)) {
                        return 1;
                    }
//printf("<<< trlK = %d\n", trlK);
                }
                break;
            }
        }

        if (cur->evt.id == CEU_INPUT__CLEAR) {
            trl->evt.id = CEU_INPUT__NONE;
        }

        if (trlK == trlF) {
            break;
        } else if (cur->evt.id == CEU_INPUT__CLEAR) {
            trlK--; trl--;
        } else {
            trlK++; trl++;
        }
    }
    return 0;
}

static void ceu_bcast (tceu_nstk level, tceu_stk* cur)
{
    if (cur->evt.id>CEU_INPUT__PRIM && cur->evt.id<CEU_EVENT__MIN) {
        switch (cur->evt.id) {
            case CEU_INPUT__WCLOCK:
                CEU_APP.wclk_min_cmp = CEU_APP.wclk_min_set;    /* swap "cmp" to last "set" */
                CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;     /* new "set" resets to inactive */
                ceu_callback_wclock_min(CEU_WCLOCK_INACTIVE, CEU_TRACE_null);
                if (CEU_APP.wclk_min_cmp <= *((s32*)cur->params)) {
                    CEU_APP.wclk_late = *((s32*)cur->params) - CEU_APP.wclk_min_cmp;
                }
                break;
#ifdef CEU_FEATURES_ASYNC
            case CEU_INPUT__ASYNC:
                CEU_APP.async_pending = 0;
                break;
#endif
        }
        if (cur->evt.id != CEU_INPUT__WCLOCK) {
            CEU_APP.wclk_late = 0;
        }
    }

    //printf(">>> BCAST[%d]: %d\n", cur->evt.id, level);
    ceu_bcast_mark(level, cur);
    while (1) {
        tceu_stk nxt;
        nxt.is_alive = 1;
        nxt.prv = cur;
        int ret = ceu_bcast_exec(level, cur, &nxt);
        if (ret) {
            ceu_assert_sys(level < 255, "too many stack levels");
            ceu_bcast(level+1, &nxt);
            if (!cur->is_alive) {
                break;
            }
        } else {
            break;
        }
    }

    CEU_APP.stack_i -= cur->params_n;
    //printf("<<< BCAST: %d\n", level);
}

CEU_API void ceu_input (tceu_nevt id, void* params)
{
    s32 dt = ceu_callback_wclock_dt(CEU_TRACE_null);
    if (dt != CEU_WCLOCK_INACTIVE) {
        tceu_evt   evt   = {CEU_INPUT__WCLOCK, {NULL}};
        tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
        tceu_stk   cur   = { evt, range, &dt, 0, 1, NULL };
        ceu_bcast(1, &cur);
    }
    if (id != CEU_INPUT__NONE) {
        tceu_evt   evt   = {id, {NULL}};
        tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
        tceu_stk   cur   = { evt, range, params, 0, 1, NULL };
        ceu_bcast(1, &cur);
    }
}

CEU_API void ceu_start (int argc, char* argv[]) {
#ifdef CEU_FEATURES_OS
    CEU_APP.argc     = argc;
    CEU_APP.argv     = argv;
    CEU_APP.end_ok   = 0;
#endif

#ifdef CEU_FEATURES_ASYNC
    CEU_APP.async_pending = 0;
#endif

    CEU_APP.wclk_late = 0;
    CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;
    CEU_APP.wclk_min_cmp = CEU_WCLOCK_INACTIVE;

    CEU_APP.root._mem.up_mem   = NULL;
    CEU_APP.root._mem.depth    = 0;

#ifdef CEU_FEATURES_TRACE
    CEU_APP.root._mem.trace.up = NULL;
#endif
#ifdef CEU_FEATURES_EXCEPTION
    CEU_APP.root._mem.catches  = NULL;
#endif
#ifdef CEU_FEATURES_LUA
    CEU_APP.root._mem.lua      = NULL;
#endif

#ifdef CEU_FEATURES_THREAD
    pthread_mutex_init(&CEU_APP.threads_mutex, NULL);
    CEU_APP.threads_head = NULL;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
#endif

    CEU_APP.stack_i = 0;

    CEU_APP.root._mem.trails_n = CEU_TRAILS_N;
    memset(&CEU_APP.root._trails, 0, CEU_TRAILS_N*sizeof(tceu_trl));
    CEU_APP.root._trails[0].evt.id = CEU_INPUT__STACKED;
    CEU_APP.root._trails[0].level  = 1;
    CEU_APP.root._trails[0].lbl    = CEU_LABEL_ROOT;

    ceu_callback_start(CEU_TRACE_null);

    tceu_evt   evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
    tceu_stk   cur   = { evt, range, NULL, 0, 1, NULL };
    ceu_bcast(1, &cur);
}
CEU_API void ceu_stop (void) {
#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    ceu_assert_ex(ceu_threads_gc(1) == 0, "bug found", CEU_TRACE_null); /* wait all terminate/free */
#endif
    ceu_callback_stop(CEU_TRACE_null);
}

/*****************************************************************************/

CEU_API int ceu_loop (int argc, char* argv[])
{
    ceu_start(argc, argv);

#ifdef CEU_FEATURES_OS
    while (!CEU_APP.end_ok)
#else
    while (1)
#endif
    {
        ceu_callback_step(CEU_TRACE_null);
#ifdef CEU_FEATURES_THREAD
        if (CEU_APP.threads_head != NULL) {
            CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
/* TODO: remove this!!! */
            CEU_THREADS_SLEEP(100); /* allow threads to do "atomic" and "terminate" */
            CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
            ceu_threads_gc(0);
        }
#endif
#ifdef CEU_FEATURES_ASYNC
        ceu_input(CEU_INPUT__ASYNC, NULL);
#endif
    }

#ifdef CEU_FEATURES_OS
    ceu_stop();

#ifdef CEU_TESTS
    printf("_ceu_tests_bcasts_ = %d\n", _ceu_tests_bcasts_);
    printf("_ceu_tests_trails_visited_ = %d\n", _ceu_tests_trails_visited_);
    fflush(stdout);
#endif

    return CEU_APP.end_val;
#else
    return 0;
#endif
}
