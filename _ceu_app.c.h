/*
* This file is automatically generated.
* http://www.ceu-lang.org/
* http://github.com/ceu-lang/ceu/
*
* CÃ©u is distributed under the MIT License:
*

Copyright (C) 2012-2016 Francisco Sant'Anna

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



/* ENV_HEADER */

#include <stdint.h>

typedef void none;

#ifndef __cplusplus
typedef unsigned char bool;
#endif
typedef unsigned char byte;
typedef unsigned int  uint;

//typedef ssize_t  ssize;       // no support in Arduino
typedef size_t   usize;

typedef int8_t    s8;
typedef int16_t  s16;
typedef int32_t  s32;
typedef int64_t  s64;

typedef uint8_t   u8;
#ifndef __AVR
typedef uint16_t u16;         // already defined in "USBAPI.h"
#endif
typedef uint32_t u32;
typedef uint64_t u64;

typedef float    real;
typedef float    r32;
typedef double   r64;


/* ENV_CEU */



/* CEU_C */

#undef CEU_FEATURES_THREAD
#undef CEU_FEATURES_LUA
#undef CEU_FEATURES_EXCEPTION
#undef CEU_FEATURES_TRACE
#undef CEU_FEATURES_DYNAMIC
#define CEU_FEATURES_ISR static
#define CEU_FEATURES_ISR_STATIC
#undef CEU_FEATURES_POOL
#undef CEU_FEATURES_OS
#undef CEU_FEATURES_ASYNC
#undef CEU_FEATURES_PAUSE
        /* CEU_FEATURES */

#include <stddef.h>     /* offsetof */
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memset, strlen */
#ifdef CEU_TESTS
#include <stdio.h>
#endif

#ifdef CEU_FEATURES_LUA
#include <lua5.3/lua.h>
#include <lua5.3/lauxlib.h>
#include <lua5.3/lualib.h>
#endif

#define S8_MIN   -127
#define S8_MAX    127
#define U8_MAX    255

#define S16_MIN  -32767
#define S16_MAX   32767
#define U16_MAX   65535

#define S32_MIN  -2147483647
#define S32_MAX   2147483647
#define U32_MAX   4294967295

#define S64_MIN  -9223372036854775807
#define S64_MAX   9223372036854775807
#define U64_MAX   18446744073709551615

typedef u16 tceu_nevt;   /* TODO */
typedef u8  tceu_nstk;   /* TODO */
typedef u8 tceu_ntrl;
typedef u8 tceu_nlbl;

#define CEU_TRAILS_N 7
#ifndef CEU_STACK_N
#define CEU_STACK_N 500
#endif

#define CEU_API
CEU_API void ceu_start (int argc, char* argv[]);
CEU_API void ceu_stop  (void);
CEU_API void ceu_input (tceu_nevt id, void* params);
CEU_API int  ceu_loop  (int argc, char* argv[]);

#ifdef CEU_FEATURES_TRACE
#define CEU_TRACE_null   ((tceu_trace){NULL,NULL,0})

typedef struct tceu_trace {
    struct tceu_trace* up;
    const char* file;
    u32 line;
} tceu_trace;
#endif

struct tceu_code_mem;
struct tceu_pool_pak;

typedef struct tceu_evt {
    tceu_nevt id;
    union {
        void* mem;                   /* CEU_INPUT__PROPAGATE_CODE, CEU_EVENT__MIN */
#ifdef CEU_FEATURES_POOL
        struct tceu_pool_pak* pak;   /* CEU_INPUT__PROPAGATE_POOL */
#endif
    };
} tceu_evt;

typedef struct tceu_range {
    struct tceu_code_mem* mem;
    tceu_ntrl             trl0;
    tceu_ntrl             trlF;
} tceu_range;

typedef struct tceu_stk {
    tceu_evt   evt;
    tceu_range range;
    void*      params;
    usize      params_n;
    bool       is_alive;
    struct tceu_stk* prv;
} tceu_stk;

struct tceu_data_Exception;

typedef struct tceu_trl {
    struct {
        tceu_evt evt;
        union {
            struct {
                tceu_nlbl lbl;
                tceu_nstk level;       /* CEU_INPUT__STACKED */
            };
#ifdef CEU_FEATURES_PAUSE
            struct {
                tceu_evt  pse_evt;
                tceu_ntrl pse_skip;
                u8        pse_paused;
            };
#endif
        };
    };
} tceu_trl;

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_catch {
    struct tceu_catch*         up;
    struct tceu_code_mem*      mem;
    tceu_ntrl                  trl;
    struct tceu_opt_Exception* exception;
} tceu_catch;
#endif

typedef struct tceu_code_mem {
#ifdef CEU_FEATURES_POOL
    struct tceu_pool_pak* pak;
#endif
    struct tceu_code_mem* up_mem;
    u8          depth;
#ifdef CEU_FEATURES_TRACE
    tceu_trace  trace;
#endif
#ifdef CEU_FEATURES_EXCEPTION
    tceu_catch* catches;
#endif
#ifdef CEU_FEATURES_LUA
    lua_State*  lua;
#endif
    bool has_term;
    tceu_ntrl   trails_n;
    tceu_trl    _trails[0];
} tceu_code_mem;

#ifdef CEU_FEATURES_THREAD
typedef struct tceu_threads_data {
    CEU_THREADS_T id;
    u8 has_started:    1;
    u8 has_terminated: 1;
    u8 has_aborted:    1;
    u8 has_notified:   1;
    struct tceu_threads_data* nxt;
} tceu_threads_data;

typedef struct {
    tceu_code_mem*     mem;
    tceu_threads_data* thread;
} tceu_threads_param;
#endif

#ifdef CEU_FEATURES_ISR_STATIC
typedef struct tceu_isr_evt {
    tceu_nevt id;
    u8        len;
    void*     args;
} tceu_isr_evt;
#else
typedef struct tceu_evt_id_params {
    tceu_nevt id;
    void*     params;
} tceu_evt_id_params;
typedef struct tceu_isr {
    void (*fun)(tceu_code_mem*);
    tceu_code_mem*     mem;
    tceu_evt_id_params evt;
} tceu_isr;
#endif

/*****************************************************************************/

/* CEU_VECTOR_H */
#include <stdlib.h>     /* NULL */
#include <string.h>     /* memcpy */

typedef struct {
    usize max;
    usize len;
    usize ini;
    usize unit;
    u8    is_ring:    1;
    u8    is_dyn:     1;
    u8    is_freezed: 1;
    byte* buf;
} tceu_vector;

#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))

#define ceu_vector_idx(vec,idx)     ((vec)->is_ring ? (((vec)->ini + (idx)) % (vec)->max) : (idx))
#define ceu_vector_buf_get(vec,idx) (&(vec)->buf[ceu_vector_idx(vec,idx)*(vec)->unit])
#define ceu_vector_ptr(vec)         (vec)

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu,CEU_TRACE(0))
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n,CEU_TRACE(0))
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,CEU_TRACE(0))
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow,CEU_TRACE(0))
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,CEU_TRACE(0))
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b,CEU_TRACE(0))
#else
#define ceu_vector_buf_set(vec,idx,buf,nu)      ceu_vector_buf_set_ex(vec,idx,buf,nu)
#define ceu_vector_copy(dst,dst_i,src,src_i,n)  ceu_vector_copy_ex(dst,dst_i,src,src_i,n)
#define ceu_vector_setmax(vec,len,freeze)       ceu_vector_setmax_ex(vec,len,freeze,_)
#define ceu_vector_setlen_could(vec,len,grow)   ceu_vector_setlen_could_ex(vec,len,grow)
#define ceu_vector_setlen(a,b,c)                ceu_vector_setlen_ex(a,b,c,_)
#define ceu_vector_geti(a,b)                    ceu_vector_geti_ex(a,b)
#endif

void  ceu_vector_init            (tceu_vector* vector, usize max, bool is_ring, bool is_dyn, usize unit, byte* buf);

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c,d)
#else
#define ceu_vector_setmax_ex(a,b,c,d) ceu_vector_setmax_ex_(a,b,c)
#endif

#ifdef CEU_FEATURES_DYNAMIC
byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );
#endif

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

#ifdef CEU_FEATURES_TRACE
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c,d)
#else
#define ceu_vector_setlen_ex(a,b,c,d) ceu_vector_setlen_ex_(a,b,c)
#endif

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 );


/* CEU_NATIVE_PRE */

#define CEU_ISR(id) ISR(id)

#define CEU_PM_IMPL

    enum {
        CEU_PM_ADC = 0,
        CEU_PM_SPI,
        CEU_PM_TIMER0,
        CEU_PM_TIMER1,
        CEU_PM_TIMER2, // TODO: works in ADC, power-save, ext-standby





        CEU_PM_USART,
        CEU_PM_TWI = 0,
        CEU_PM_N,
    };

# 1 "./libraries/driver-pm/avr/../pm.c" 1




static u32 ceu_pm_state = 0; // TODO: max 32 devices

void ceu_pm_init (void);

void ceu_pm_sleep (void);

int ceu_pm_get (int dev) {
    return bitRead(ceu_pm_state, dev);
}

void ceu_pm_set (u8 dev, bool v) {
    if (v) {
        bitSet(ceu_pm_state, dev);
    } else {
        bitClear(ceu_pm_state, dev);
    }
}
# 22 "./libraries/driver-pm/avr/pm.ceu" 2
#include "LowPower.h"
#include "LowPower.cpp"

    void ceu_pm_init (void) {
    }

    void ceu_pm_sleep (void)
    {
# 45 "./libraries/driver-pm/avr/pm.ceu"
        if (ceu_pm_get(CEU_PM_TIMER0) || ceu_pm_get(CEU_PM_TIMER1) ||
            ceu_pm_get(CEU_PM_TIMER2) || ceu_pm_get(CEU_PM_USART) ||
            ceu_pm_get(CEU_PM_TWI) || ceu_pm_get(CEU_PM_SPI))
        {

            LowPower.idle(SLEEP_FOREVER,
                          (adc_t) ceu_pm_get(CEU_PM_ADC),





                          (timer2_t) ceu_pm_get(CEU_PM_TIMER2),
                          (timer1_t) ceu_pm_get(CEU_PM_TIMER1),
                          (timer0_t) ceu_pm_get(CEU_PM_TIMER0),
                          (spi_t) ceu_pm_get(CEU_PM_SPI),



                          (usart0_t) ceu_pm_get(CEU_PM_USART),
                          (twi_t) ceu_pm_get(CEU_PM_TWI));
        }
        else if (ceu_pm_get(CEU_PM_ADC))
        {
            LowPower.adcNoiseReduction(SLEEP_FOREVER,
                                       (adc_t) ceu_pm_get(CEU_PM_ADC),
                                       TIMER2_OFF);
        }
        else
        {
            LowPower.powerDown(SLEEP_FOREVER, ADC_OFF, BOD_OFF);
        }


    }

#define USART_BAUD(bps) ((F_CPU/4/bps - 1) / 2)

#include <stdio.h>
    typedef struct sockaddr sockaddr;
    typedef struct sockaddr_in sockaddr_in;
    typedef struct sockaddr_storage sockaddr_storage;

#include <string.h>

    /* A utility function to reverse a string  */
    void reverse(char str[], int length)
    {
        int start = 0;
        int end_ = length -1;
        while (start < end_)
        {
            char tmp = *(str+start);
            *(str+start) = *(str+end_);
            *(str+end_) = tmp;
            start++;
            end_--;
        }
    }

    // Implementation of itoa()
    usize ceu_itona(int num, char* str, int base, usize max)
    {
        usize i = 0;
        bool isNegative = 0;

        /* Handle 0 explicitely, otherwise empty string is printed for 0 */
        if (num == 0) {
            if (i >= max) return 0;
            str[i++] = '0';
            if (i >= max) return 0;
            str[i] = '\0';
            return i+1;
        }

        // In standard itoa(), negative numbers are handled only with 
        // base 10. Otherwise numbers are considered unsigned.
        if (num < 0 && base == 10) {
            isNegative = 1;
            num = -num;
        }

        // Process individual digits
        while (num != 0) {
            int rem = num % base;
            if (i >= max) return 0;
            str[i++] = (rem > 9)? (rem-10) + 'A' : rem + '0';
            num = num/base;
        }

        // If number is negative, append '-'
        if (isNegative) {
            if (i >= max) return 0;
            str[i++] = '-';
        }

        if (i >= max) return 0;
        str[i] = '\0'; // Append string terminator

        // Reverse the string
        reverse(str, i);

        return i+1;
    }


/* EVENTS_ENUM */

enum {
    /* non-emitable */
    CEU_INPUT__NONE = 0,
    CEU_INPUT__STACKED,
    CEU_INPUT__FINALIZE,
    CEU_INPUT__THROW,
    CEU_INPUT__PAUSE_BLOCK,
    CEU_INPUT__PROPAGATE_CODE,
    CEU_INPUT__PROPAGATE_POOL,

    /* emitable */
    CEU_INPUT__CLEAR,           /* 7 */
    CEU_INPUT__PAUSE,
    CEU_INPUT__RESUME,
    CEU_INPUT__CODE_TERMINATED,
CEU_INPUT__PRIM,
    CEU_INPUT__ASYNC,
    CEU_INPUT__THREAD,
    CEU_INPUT__WCLOCK,

//CEU_INPUT__MIN,
    CEU_INPUT_USART_TX_DONE,
CEU_INPUT_INT0,

//CEU_INPUT__MAX,

CEU_EVENT__MIN,
    CEU_EVENT_LOCK_OK_UNLOCKED,

};

enum {
    CEU_OUTPUT__NONE = 0,
    
};

/* CEU_MAIN */


#if 0
#define ceu_callback_log_num(a,b)
#define ceu_callback_log_str(a,b)
#define ceu_callback_log_flush(a)
#define ceu_callback_wclock_min(a,b)
#define ceu_callback_abort(a,b)
#define ceu_callback_terminating(a)
#define ceu_callback_wclock_dt(a) CEU_WCLOCK_INACTIVE
#define ceu_callback_start(a)
#define ceu_callback_stop(a)
#define ceu_callback_step(a)
#define ceu_callback_realloc(a,b,c) NULL
#define ceu_callback_free(a,b)
#endif

//#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"

#ifdef ceu_assert_ex
#define ceu_assert(a,b) ceu_assert_ex(a,b,NONE)
#else
#ifdef CEU_FEATURES_TRACE
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_trace(trace, msg);                                      \
        ceu_callback_abort(0, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg), CEU_TRACE(0))
#else
#define ceu_assert_ex(v,msg,trace)                                  \
    if (!(v)) {                                                     \
        ceu_callback_abort(0, trace);   \
    }
#define ceu_assert(v,msg) ceu_assert_ex((v),(msg),NONE)
#endif
#endif

#ifndef ceu_assert_sys
#define ceu_assert_sys(v,msg)   \
    if (!(v)) {                 \
        ceu_callback_log_str(msg, CEU_TRACE_null);  \
        ceu_callback_abort(0, CEU_TRACE_null);      \
    }
#endif

#ifdef CEU_FEATURES_TRACE
static void ceu_trace (tceu_trace trace, const char* msg) {
    static bool IS_FIRST = 1;
    bool is_first = IS_FIRST;

    IS_FIRST = 0;

    if (trace.up != NULL) {
        ceu_trace(*trace.up, msg);
    }

    if (is_first) {
        IS_FIRST = 1;
        ceu_callback_log_str("\n", CEU_TRACE_null);
    }

    ceu_callback_log_str("[",        CEU_TRACE_null);
    ceu_callback_log_str(trace.file, CEU_TRACE_null);
    ceu_callback_log_str(":",        CEU_TRACE_null);
    ceu_callback_log_num(trace.line, CEU_TRACE_null);
    ceu_callback_log_str("]",        CEU_TRACE_null);
    ceu_callback_log_str(" -> ",     CEU_TRACE_null);

    if (is_first) {
        ceu_callback_log_str("runtime error: ", CEU_TRACE_null);
        ceu_callback_log_str(msg,               CEU_TRACE_null);
        ceu_callback_log_str("\n",              CEU_TRACE_null);
        ceu_callback_log_flush(CEU_TRACE_null);
    }
}
#else
#define ceu_trace(a,b)
#endif

#define CEU_ISRS_N 2

/* CEU_ISRS_DEFINES */
#define CEU_ISR__USART_TX_vect
#define CEU_ISR__INT0_vect


/* EVENTS_DEFINES */
#define _CEU_INPUT_USART_TX_DONE_
#define _CEU_INPUT_INT0_


/* CEU_DATAS_HIERS */
typedef s16 tceu_ndata;  /* TODO */
enum {
        CEU_DATA_Exception = 0,
};

tceu_ndata CEU_DATA_SUPERS_Exception [] = {
        0,
};
tceu_ndata CEU_DATA_NUMS_Exception [] = {
        CEU_DATA_Exception,
};


static int ceu_data_is (tceu_ndata* supers, tceu_ndata me, tceu_ndata cmp) {
    return (me==cmp || (me!=0 && ceu_data_is(supers,supers[me],cmp)));
}

#ifdef CEU_FEATURES_TRACE
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c,d)
#else
#define ceu_data_as(a,b,c,d) ceu_data_as_(a,b,c)
#endif

__attribute__((__unused__))
static void* ceu_data_as_ (tceu_ndata* supers, tceu_ndata* me, tceu_ndata cmp
#ifdef CEU_FEATURES_TRACE
                         , tceu_trace trace
#endif
                         )
{
    ceu_assert_ex(ceu_data_is(supers, *me, cmp), "invalid cast `as`", trace);
    return me;
}

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a,b)
#else
#define CEU_OPTION_EVT(a,b) CEU_OPTION_EVT_(a)
#endif

__attribute__((__unused__))
static tceu_evt* CEU_OPTION_EVT_ (tceu_evt* alias
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(alias != NULL, "value is not set", trace);
    return alias;
}

/* CEU_VECTOR_C */
void ceu_vector_init (tceu_vector* vector, usize max, bool is_ring,
                      bool is_dyn, usize unit, byte* buf) {
    vector->len        = 0;
    vector->max        = max;
    vector->ini        = 0;
    vector->unit       = unit;
    vector->is_dyn     = is_dyn;
    vector->is_ring    = is_ring;
    vector->is_freezed = 0;
    vector->buf        = buf;
}

#ifdef CEU_FEATURES_DYNAMIC
byte* ceu_vector_setmax_ex_      (tceu_vector* vector, usize len, bool freeze
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(vector->is_dyn, "static vector", trace);

    if (vector->max == len) {
        goto END;
    }

    if (len == 0) {
        /* free */
        if (vector->buf != NULL) {
            vector->max = 0;
            ceu_callback_free(vector->buf, trace);
            vector->buf = NULL;
        }
    } else {
        ceu_assert_ex(len > vector->max, "not implemented: shrinking vectors", trace);
        vector->buf = (byte*) ceu_callback_realloc(vector->buf, len*vector->unit, trace);

        if (vector->is_ring && vector->ini>0) {
            /*
             * [X,Y,Z,I,J,K,L,#####,A,B]       -> (grow) ->
             * [X,Y,Z,I,J,K,L,#####,A,B,-,-,-] -> (1st memcpy) ->
             * [?,?,?,I,J,K,L,#####,A,B,X,Y,Z] -> (2nd memmove) ->
             * [I,J,K,L,#####,-,-,-,A,B,X,Y,Z]
             */
            usize dif = len - vector->max;
            usize rig = vector->max - vector->ini;
            if (vector->len > rig) { // if wrap-around then need to shuffle
                usize num = vector->len - rig;
                memcpy(&vector->buf[vector->max * vector->unit], // -,-,-
                       &vector->buf[0],                          // X,Y,Z
                       (num > dif ? dif : num)  * vector->unit); // 3
                if (num > dif) {
                    memmove(&vector->buf[0],                     // X,Y,Z
                            &vector->buf[dif * vector->unit],    // I,J,K,L
                            (num - dif)      * vector->unit);    // rest
                }
            }
        }

        vector->max = len;
    }

    if (freeze) {
        vector->is_freezed = 1;
    }

END:
    return vector->buf;
}
#endif

int   ceu_vector_setlen_could_ex (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        if (len > vector->len) {
            return 0;
        }
    }

    /* fixed size */
#ifdef CEU_FEATURES_DYNAMIC
    if (!vector->is_dyn || vector->is_freezed)
#endif
    {
        if (len > vector->max) {
            return 0;
        }

    /* variable size */
    }
#ifdef CEU_FEATURES_DYNAMIC
    else
    {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                if (len != 0) {
                    return 0;
                }
            }
        }
    }
#endif

    return 1;
}

void  ceu_vector_setlen_ex_      (tceu_vector* vector, usize len, bool grow
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    /* must fit w/o growing */
    if (!grow) {
        ceu_assert_ex(len <= vector->len, "access out of bounds", trace);
    }

    /* fixed size */
#ifdef CEU_FEATURES_DYNAMIC
    if (!vector->is_dyn || vector->is_freezed)
#endif
    {
        ceu_assert_ex(len <= vector->max, "access out of bounds", trace);

    /* variable size */
    }
#ifdef CEU_FEATURES_DYNAMIC
    else
    {
        if (len <= vector->max) {
            /* ok */    /* len already within limits */
/* TODO: shrink memory */
        } else {
            /* grow vector */
            if (ceu_vector_setmax_ex(vector,len,0,trace) == NULL) {
                ceu_assert_ex(len==0, "access out of bounds", trace);
            }
        }
    }
#endif

    if (vector->is_ring && len<vector->len) {
        vector->ini = (vector->ini + (vector->len - len)) % vector->max;
    }

    vector->len = len;
}

byte* ceu_vector_geti_ex         (tceu_vector* vector, usize idx
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    ceu_assert_ex(idx < vector->len, "access out of bounds", trace);
    return ceu_vector_buf_get(vector, idx);
}

void  ceu_vector_buf_set_ex      (tceu_vector* vector, usize idx, byte* buf, usize nu
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize n = ((nu % vector->unit) == 0) ? nu/vector->unit : nu/vector->unit+1;
#if 0
    if (vector->len < idx+n) {
        char err[50];
        snprintf(err,50, "access out of bounds : length=%ld, index=%ld", vector->len, idx+n);
        ceu_assert_ex(0, err, file, line);
    }
#else
    ceu_assert_ex((vector->len >= idx+n), "access out of bounds", trace);
#endif

    usize k  = (vector->max - ceu_vector_idx(vector,idx));
    usize ku = k * vector->unit;

    if (vector->is_ring && ku<nu) {
        memcpy(ceu_vector_buf_get(vector,idx),   buf,    ku);
        memcpy(ceu_vector_buf_get(vector,idx+k), buf+ku, nu-ku);
    } else {
        memcpy(ceu_vector_buf_get(vector,idx), buf, nu);
    }
}

void  ceu_vector_copy_ex         (tceu_vector* dst, usize dst_i, tceu_vector* src, usize src_i, usize n
#ifdef CEU_FEATURES_TRACE
                                 , tceu_trace trace
#endif
                                 )
{
    usize unit = dst->unit;
    ceu_assert_ex((src->unit == dst->unit), "incompatible vectors", trace);

    ceu_assert_ex((src->len >= src_i+n), "access out of bounds", trace);
    ceu_vector_setlen_ex(dst, MAX(dst->len,dst_i+n), 1, trace);

    usize dif_src = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
    usize dif_dst = MIN(n, (dst->max - ceu_vector_idx(dst,dst_i)));
    usize dif = MIN(dif_src, dif_dst);

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);

    dst_i += dif;
    src_i += dif;
    n -= dif;

    if (n == 0) {
        return;
    }

    if (dif_src > dif_dst) {
        dif = MIN(n, (src->max - ceu_vector_idx(src,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    } else if (dif_dst > dif_src) {
        dif = MIN(n, (dst->max - ceu_vector_idx(dst,src_i)));
        memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), dif*unit);
        dst_i += dif;
        src_i += dif;
        n -= dif;
    }

    if (n == 0) {
        return;
    }

    memcpy(ceu_vector_buf_get(dst,dst_i), ceu_vector_buf_get(src,src_i), n);
}


#ifdef CEU_FEATURES_POOL

/* CEU_POOL_C */
#include <stdlib.h>     /* NULL */

typedef struct {
    usize   len;
    usize   free;
    usize   index;
    usize   unit;
    byte*   buf;
    byte**  queue; /* NULL on dynamic pools */
} tceu_pool;

void ceu_pool_init (tceu_pool* pool, usize len, usize unit, byte** queue, byte* buf)
{
    usize i;
    pool->len   = len;
    pool->free  = len;
    pool->index = 0;
    pool->unit  = unit;
    pool->queue = queue;
    pool->buf   = buf;
    for (i=0; i<len; i++) {
        queue[i] = &buf[i*unit];
    }
}

byte* ceu_pool_alloc (tceu_pool* pool) {
    byte* ret;

    if (pool->free == 0) {
        return NULL;
    }

    pool->free--;
    ret = pool->queue[pool->index];
    pool->queue[pool->index++] = NULL;
    if (pool->index == pool->len) {
        pool->index = 0;
    }
    return ret;
}

void ceu_pool_free (tceu_pool* pool, byte* val) {
    usize empty = pool->index + pool->free;
    if (empty >= pool->len) {
        empty -= pool->len;
    }
    pool->queue[empty] = val;
    pool->free++;
}


typedef struct tceu_code_mem_dyn {
    struct tceu_code_mem_dyn* prv;
    struct tceu_code_mem_dyn* nxt;
    u8 is_alive: 1;
    tceu_code_mem mem[0];   /* actual tceu_code_mem is in sequence */
} tceu_code_mem_dyn;

typedef struct tceu_pool_pak {
    tceu_pool         pool;
    tceu_code_mem_dyn first;
    tceu_code_mem*    up_mem;
    u8                n_traversing;
} tceu_pool_pak;

#endif

/* CEU_DATAS_MEMS */

#pragma pack(push,1)
typedef struct tceu_data_Lock {
    #line 1 "libraries/driver-gpio/examples/out-01.ceu"
bool  is_locked;
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
} tceu_data_Lock;

typedef struct tceu_data_Exception {
    tceu_ndata _enum;
    #line 1 "libraries/driver-gpio/examples/out-01.ceu"
char*  message;
} tceu_data_Exception;

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_tceu_opt_int(a,b) CEU_OPTION_tceu_opt_int_(a,b)
#else
#define CEU_OPTION_tceu_opt_int(a,b) CEU_OPTION_tceu_opt_int_(a)
#endif
typedef struct tceu_opt_int {
    bool      is_set;
    int value;
} tceu_opt_int;

static tceu_opt_int* CEU_OPTION_tceu_opt_int_ (tceu_opt_int* opt
#ifdef CEU_FEATURES_TRACE
                                              , tceu_trace trace
#endif
                                              ) {
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}


#pragma pack(pop)

#ifdef CEU_FEATURES_EXCEPTION
typedef struct tceu_opt_Exception {
    bool      is_set;
    tceu_data_Exception value;
} tceu_opt_Exception;

#ifdef CEU_FEATURES_TRACE
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a,b)
#else
#define CEU_OPTION_tceu_opt_Exception(a,b) CEU_OPTION_tceu_opt_Exception_(a)
#endif

static tceu_opt_Exception* CEU_OPTION_tceu_opt_Exception_ (tceu_opt_Exception* opt
#ifdef CEU_FEATURES_TRACE
                                                          , tceu_trace trace
#endif
                                                          )
{
    ceu_assert_ex(opt->is_set, "value is not set", trace);
    return opt;
}
#endif

/*****************************************************************************/

typedef struct tceu_input_USART_TX_DONE {
} tceu_input_USART_TX_DONE;
typedef struct tceu_input_INT0 {
} tceu_input_INT0;

typedef struct tceu_event___lpar____rpar__ {
} tceu_event___lpar____rpar__;

typedef struct tceu_code_mem_USART_Init {
    tceu_code_mem _mem;
    tceu_trl      _trails[5];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
struct {
#line 53 "./libraries/driver-usart/avr/usart.ceu"
int  bps;
union {
union {
};
struct {
union {
struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
};
};
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_USART_Init;
typedef struct tceu_code_mem_USART_Tx {
    tceu_code_mem _mem;
    tceu_trl      _trails[7];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
union {
struct {
union {
};
};
};
union {
struct {
#line 69 "./libraries/driver-usart/avr/usart.ceu"
tceu_vector* buf;
union {
union {
};
struct {
union {
struct {
union {
struct {
union {
struct {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
struct {
union {
struct {
union {
};
};
};
union {
struct {
union {
struct {
union {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
union {
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_USART_Tx;
typedef struct tceu_code_mem_INT0_Get {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 5 "./libraries/driver-gpio/avr/int0.ceu"
bool  _ret;
union {
struct {
union {
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_INT0_Get;
typedef struct tceu_code_mem_String_Check {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 74 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
union {
union {
};
struct {
union {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Check;
typedef struct tceu_code_mem_String_Print {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 83 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str;
union {
union {
};
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Print;
typedef struct tceu_code_mem_String_Append_STR {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 90 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
#line 90 "/home/anny/dev/ceu/include/string.ceu"
char*  src;
union {
union {
};
union {
};
struct {
union {
struct {
union {
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Append_STR;
typedef struct tceu_code_mem_String_Append_INT {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 96 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
#line 96 "/home/anny/dev/ceu/include/string.ceu"
int  src;
#line 96 "/home/anny/dev/ceu/include/string.ceu"
tceu_opt_int  base;
union {
union {
};
union {
};
union {
};
struct {
union {
struct {
#line 105 "/home/anny/dev/ceu/include/string.ceu"
usize  n;
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Append_INT;
typedef struct tceu_code_mem_String_Append_REAL {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
union {
struct {
#line 110 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* dst;
#line 110 "/home/anny/dev/ceu/include/string.ceu"
r64  src;
#line 110 "/home/anny/dev/ceu/include/string.ceu"
tceu_opt_int  precision;
union {
union {
};
union {
};
union {
};
struct {
union {
struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Append_REAL;
typedef struct tceu_code_mem_String_Equal {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 131 "/home/anny/dev/ceu/include/string.ceu"
bool  _ret;
union {
struct {
#line 131 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str1;
#line 131 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str2;
union {
union {
};
union {
};
struct {
union {
struct {
#line 132 "/home/anny/dev/ceu/include/string.ceu"
int  result;
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Equal;
typedef struct tceu_code_mem_String_Equal_STR {
    tceu_code_mem _mem;
    tceu_trl      _trails[1];
    byte          _params[0];
    union {
        /* MULTIS */
        struct {
#line 144 "/home/anny/dev/ceu/include/string.ceu"
bool  _ret;
union {
struct {
#line 144 "/home/anny/dev/ceu/include/string.ceu"
tceu_vector* str1;
#line 144 "/home/anny/dev/ceu/include/string.ceu"
char*  str2;
union {
union {
};
union {
};
struct {
union {
struct {
#line 145 "/home/anny/dev/ceu/include/string.ceu"
int  result;
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
};
};
};
};
};
};
    };
} tceu_code_mem_String_Equal_STR;
typedef struct tceu_code_mem_ROOT {
    tceu_code_mem _mem;
    tceu_trl      _trails[7];
    byte          _params[0];
    struct {
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
#line 1 "libraries/driver-gpio/examples/out-01.ceu"
int  _RET;
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 6 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 25 "././include/arduino/arduino.ceu"
#line 29 "./libraries/driver-usart/avr/usart.ceu"
#line 31 "./libraries/driver-usart/avr/usart.ceu"
#line 33 "./libraries/driver-usart/avr/usart.ceu"
#line 33 "./libraries/driver-usart/avr/usart.ceu"
#line 1 "./libraries/driver-gpio/avr/int0.ceu"
#line 9 "./libraries/driver-gpio/avr/int0.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 4 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 13 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 20 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 31 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 49 "/home/anny/dev/ceu/include/c.ceu"
#line 8 "/home/anny/dev/ceu/include/string.ceu"
#line 9 "/home/anny/dev/ceu/include/string.ceu"
union {
struct {
#line 5 "./libraries/driver-usart/avr/../usart.ceu"
#line 6 "./libraries/driver-usart/avr/../usart.ceu"
#line 7 "./libraries/driver-usart/avr/../usart.ceu"
#line 17 "./libraries/driver-usart/avr/usart.ceu"
tceu_data_Lock  usart_lock;
#line 18 "./libraries/driver-usart/avr/usart.ceu"
u8  usart_pm_refs;
#line 5 "./libraries/driver-gpio/avr/int0.ceu"
#line 74 "/home/anny/dev/ceu/include/string.ceu"
#line 83 "/home/anny/dev/ceu/include/string.ceu"
#line 90 "/home/anny/dev/ceu/include/string.ceu"
#line 96 "/home/anny/dev/ceu/include/string.ceu"
#line 110 "/home/anny/dev/ceu/include/string.ceu"
#line 131 "/home/anny/dev/ceu/include/string.ceu"
#line 144 "/home/anny/dev/ceu/include/string.ceu"
union {
struct {
struct {
union {
struct {
#line 11 "libraries/driver-gpio/examples/out-01.ceu"
bool  v_590;
#line 13 "libraries/driver-gpio/examples/out-01.ceu"
byte str_597_buf[2];
tceu_vector str_597;
union {
struct {
union {
tceu_code_mem_USART_Init __mem_582;
};
union {
struct {
union {
};
};
struct {
union {
};
};
tceu_code_mem_USART_Tx __mem_628;
};
};
};
};
};
};
};
};
};
};
};
} tceu_code_mem_ROOT;



enum {
    CEU_LABEL_NONE = 0,
    CEU_LABEL_ROOT,
CEU_LABEL_Block__CLR_2,
CEU_LABEL_Block__CLR_3,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_4,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_5,
CEU_LABEL_USART_Init_Par_Or__OUT_6,
CEU_LABEL_USART_Init_Par_Or__CLR_7,
CEU_LABEL_USART_Init_Block__CLR_8,
CEU_LABEL_USART_Init_Finalize_Case__IN_9,
CEU_LABEL_USART_Init_Block__CLR_10,
CEU_LABEL_USART_Init_Block__CLR_11,
CEU_LABEL_USART_Init_Do__OUT_12,
CEU_LABEL_USART_Init_Do__CLR_13,
CEU_LABEL_USART_Init_Block__CLR_14,
CEU_LABEL_Code_USART_Init,
CEU_LABEL_USART_Init_Code_USART_Init__TERM_16,
CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_17,
CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_18,
CEU_LABEL_USART_Tx_Par_Or__OUT_19,
CEU_LABEL_USART_Tx_Par_Or__CLR_20,
CEU_LABEL_USART_Tx_Block__CLR_21,
CEU_LABEL_USART_Tx_Finalize_Case__IN_22,
CEU_LABEL_USART_Tx_Block__CLR_23,
CEU_LABEL_USART_Tx_Block__CLR_24,
CEU_LABEL_USART_Tx_Do__OUT_25,
CEU_LABEL_USART_Tx_Do__CLR_26,
CEU_LABEL_USART_Tx_Block__CLR_27,
CEU_LABEL_Code_USART_Tx,
CEU_LABEL_USART_Tx_Code_USART_Tx__TERM_29,
CEU_LABEL_Block__CLR_30,
CEU_LABEL_Block__CLR_31,
CEU_LABEL_Block__CLR_32,
CEU_LABEL_Async_Isr__FIN_33,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_34,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_35,
CEU_LABEL_USART_Init_Par_Or__OUT_36,
CEU_LABEL_USART_Init_Par_Or__CLR_37,
CEU_LABEL_USART_Init_Block__CLR_38,
CEU_LABEL_USART_Init_Finalize_Case__IN_39,
CEU_LABEL_USART_Init_Par_Or_sub_1_IN_40,
CEU_LABEL_USART_Init_Par_Or_sub_2_IN_41,
CEU_LABEL_USART_Init_Par_Or__OUT_42,
CEU_LABEL_USART_Init_Par_Or__CLR_43,
CEU_LABEL_USART_Init_Block__CLR_44,
CEU_LABEL_USART_Init_Finalize_Case__IN_45,
CEU_LABEL_USART_Init_Block__CLR_46,
CEU_LABEL_USART_Init_Block__CLR_47,
CEU_LABEL_USART_Init_Block__CLR_48,
CEU_LABEL_USART_Init_Do__OUT_49,
CEU_LABEL_USART_Init_Do__CLR_50,
CEU_LABEL_USART_Init_Block__CLR_51,
CEU_LABEL_USART_Init_Code_USART_Init__TERM_52,
CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_53,
CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_54,
CEU_LABEL_USART_Tx_Par_Or__OUT_55,
CEU_LABEL_USART_Tx_Par_Or__CLR_56,
CEU_LABEL_USART_Tx_Block__CLR_57,
CEU_LABEL_USART_Tx_Finalize_Case__IN_58,
CEU_LABEL_USART_Tx_Await_ok_unlocked__OUT_59,
CEU_LABEL_USART_Tx_Block__CLR_60,
CEU_LABEL_USART_Tx_Block__CLR_61,
CEU_LABEL_USART_Tx_Block__CLR_62,
CEU_LABEL_USART_Tx_Loop__CLR_63,
CEU_LABEL_USART_Tx_Loop_Continue__CNT_64,
CEU_LABEL_USART_Tx_Loop_Continue__CLR_65,
CEU_LABEL_USART_Tx_Loop_Break__OUT_66,
CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_67,
CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_68,
CEU_LABEL_USART_Tx_Par_Or__OUT_69,
CEU_LABEL_USART_Tx_Par_Or__CLR_70,
CEU_LABEL_USART_Tx_Emit_Int__OUT_71,
CEU_LABEL_USART_Tx_Block__CLR_72,
CEU_LABEL_USART_Tx_Finalize_Case__IN_73,
CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_74,
CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_75,
CEU_LABEL_USART_Tx_Par_Or__OUT_76,
CEU_LABEL_USART_Tx_Par_Or__CLR_77,
CEU_LABEL_USART_Tx_Block__CLR_78,
CEU_LABEL_USART_Tx_Block__CLR_79,
CEU_LABEL_USART_Tx_Block__CLR_80,
CEU_LABEL_USART_Tx_Finalize_Case__IN_81,
CEU_LABEL_USART_Tx_Await_USART_TX_DONE__OUT_82,
CEU_LABEL_USART_Tx_Block__CLR_83,
CEU_LABEL_USART_Tx_Block__CLR_84,
CEU_LABEL_USART_Tx_Do__OUT_85,
CEU_LABEL_USART_Tx_Do__CLR_86,
CEU_LABEL_USART_Tx_Block__CLR_87,
CEU_LABEL_USART_Tx_Block__CLR_88,
CEU_LABEL_USART_Tx_Block__CLR_89,
CEU_LABEL_USART_Tx_Do__OUT_90,
CEU_LABEL_USART_Tx_Do__CLR_91,
CEU_LABEL_USART_Tx_Block__CLR_92,
CEU_LABEL_USART_Tx_Code_USART_Tx__TERM_93,
CEU_LABEL_INT0_Get_Block__CLR_94,
CEU_LABEL_INT0_Get_Block__CLR_95,
CEU_LABEL_INT0_Get_Block__CLR_96,
CEU_LABEL_INT0_Get_Do__OUT_97,
CEU_LABEL_INT0_Get_Do__CLR_98,
CEU_LABEL_INT0_Get_Block__CLR_99,
CEU_LABEL_Code_INT0_Get,
CEU_LABEL_INT0_Get_Code_INT0_Get__TERM_101,
CEU_LABEL_Block__CLR_102,
CEU_LABEL_Async_Isr__FIN_103,
CEU_LABEL_String_Check_Block__CLR_104,
CEU_LABEL_String_Check_Block__CLR_105,
CEU_LABEL_String_Check_Block__CLR_106,
CEU_LABEL_String_Check_Block__CLR_107,
CEU_LABEL_String_Check_Block__CLR_108,
CEU_LABEL_String_Check_Do__OUT_109,
CEU_LABEL_String_Check_Do__CLR_110,
CEU_LABEL_String_Check_Block__CLR_111,
CEU_LABEL_Code_String_Check,
CEU_LABEL_String_Check_Code_String_Check__TERM_113,
CEU_LABEL_String_Print_Block__CLR_114,
CEU_LABEL_String_Print_Block__CLR_115,
CEU_LABEL_String_Print_Block__CLR_116,
CEU_LABEL_String_Print_Do__OUT_117,
CEU_LABEL_String_Print_Do__CLR_118,
CEU_LABEL_String_Print_Block__CLR_119,
CEU_LABEL_Code_String_Print,
CEU_LABEL_String_Print_Code_String_Print__TERM_121,
CEU_LABEL_String_Append_STR_Block__CLR_122,
CEU_LABEL_String_Append_STR_Block__CLR_123,
CEU_LABEL_String_Append_STR_Block__CLR_124,
CEU_LABEL_String_Append_STR_Do__OUT_125,
CEU_LABEL_String_Append_STR_Do__CLR_126,
CEU_LABEL_String_Append_STR_Block__CLR_127,
CEU_LABEL_Code_String_Append_STR,
CEU_LABEL_String_Append_STR_Code_String_Append_STR__TERM_129,
CEU_LABEL_String_Append_INT_Block__CLR_130,
CEU_LABEL_String_Append_INT_Block__CLR_131,
CEU_LABEL_String_Append_INT_Block__CLR_132,
CEU_LABEL_String_Append_INT_Block__CLR_133,
CEU_LABEL_String_Append_INT_Block__CLR_134,
CEU_LABEL_String_Append_INT_Do__OUT_135,
CEU_LABEL_String_Append_INT_Do__CLR_136,
CEU_LABEL_String_Append_INT_Block__CLR_137,
CEU_LABEL_Code_String_Append_INT,
CEU_LABEL_String_Append_INT_Code_String_Append_INT__TERM_139,
CEU_LABEL_String_Append_REAL_Block__CLR_140,
CEU_LABEL_String_Append_REAL_Block__CLR_141,
CEU_LABEL_String_Append_REAL_Block__CLR_142,
CEU_LABEL_String_Append_REAL_Block__CLR_143,
CEU_LABEL_String_Append_REAL_Block__CLR_144,
CEU_LABEL_String_Append_REAL_Do__OUT_145,
CEU_LABEL_String_Append_REAL_Do__CLR_146,
CEU_LABEL_String_Append_REAL_Block__CLR_147,
CEU_LABEL_Code_String_Append_REAL,
CEU_LABEL_String_Append_REAL_Code_String_Append_REAL__TERM_149,
CEU_LABEL_String_Equal_Block__CLR_150,
CEU_LABEL_String_Equal_Block__CLR_151,
CEU_LABEL_String_Equal_Block__CLR_152,
CEU_LABEL_String_Equal_Block__CLR_153,
CEU_LABEL_String_Equal_Block__CLR_154,
CEU_LABEL_String_Equal_Do__OUT_155,
CEU_LABEL_String_Equal_Do__CLR_156,
CEU_LABEL_String_Equal_Block__CLR_157,
CEU_LABEL_Code_String_Equal,
CEU_LABEL_String_Equal_Code_String_Equal__TERM_159,
CEU_LABEL_String_Equal_STR_Block__CLR_160,
CEU_LABEL_String_Equal_STR_Block__CLR_161,
CEU_LABEL_String_Equal_STR_Block__CLR_162,
CEU_LABEL_String_Equal_STR_Block__CLR_163,
CEU_LABEL_String_Equal_STR_Block__CLR_164,
CEU_LABEL_String_Equal_STR_Do__OUT_165,
CEU_LABEL_String_Equal_STR_Do__CLR_166,
CEU_LABEL_String_Equal_STR_Block__CLR_167,
CEU_LABEL_Code_String_Equal_STR,
CEU_LABEL_String_Equal_STR_Code_String_Equal_STR__TERM_169,
CEU_LABEL_Await_INT0__OUT_170,
CEU_LABEL_Par_Or_sub_1_IN_171,
CEU_LABEL_Par_Or_sub_2_IN_172,
CEU_LABEL_Par_Or__OUT_173,
CEU_LABEL_Par_Or__CLR_174,
CEU_LABEL_Await_Spawn__OUT_175,
CEU_LABEL_Block__CLR_176,
CEU_LABEL_Block__CLR_177,
CEU_LABEL_Await_Await__OUT_178,
CEU_LABEL_Block__CLR_179,
CEU_LABEL_Do__OUT_180,
CEU_LABEL_Do__CLR_181,
CEU_LABEL_Block__CLR_182,
CEU_LABEL_Loop__CLR_183,
CEU_LABEL_Loop_Continue__CNT_184,
CEU_LABEL_Loop_Continue__CLR_185,
CEU_LABEL_Loop_Break__OUT_186,
CEU_LABEL_Block__CLR_187,
CEU_LABEL_Do__OUT_188,
CEU_LABEL_Do__CLR_189,
CEU_LABEL_Block__CLR_190,

};

/*****************************************************************************/

typedef struct tceu_app {
#ifdef CEU_FEATURES_OS
    int    argc;
    char** argv;

    bool end_ok;
    int  end_val;
#endif

    /* ASYNC */
#ifdef CEU_FEATURES_ASYNC
    bool async_pending;
#endif

    /* WCLOCK */
    s32 wclk_late;
    s32 wclk_min_set;
    s32 wclk_min_cmp;

#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_T threads_mutex;
    tceu_threads_data*  threads_head;   /* linked list of threads alive */
    tceu_threads_data** cur_;           /* TODO: HACK_6 "gc" mutable iterator */
#endif

    byte  stack[CEU_STACK_N];
    usize stack_i;

    tceu_code_mem_ROOT root;
} tceu_app;

CEU_API static tceu_app CEU_APP;

/*****************************************************************************/

__attribute__((__unused__))
static tceu_code_mem* ceu_outer (tceu_code_mem* mem, u8 n) {
    for (; mem->depth!=n; mem=mem->up_mem);
    return mem;
}

/*****************************************************************************/

#define CEU_WCLOCK_INACTIVE INT32_MAX

#ifdef CEU_FEATURES_TRACE
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c,d)
#else
#define ceu_wclock(a,b,c,d) ceu_wclock_(a,b,c)
#endif

__attribute__((__unused__))
static int ceu_wclock_ (s32 dt, s32* set, s32* sub
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
                      )
{
    s32 t;          /* expiring time of track to calculate */
    int ret = 0;    /* if track expired (only for "sub") */

    /* SET */
    if (set != NULL) {
        t = dt - CEU_APP.wclk_late;
        *set = t;

    /* SUB */
    } else {
        t = *sub;
        if ((t > CEU_APP.wclk_min_cmp) || (t > dt)) {
            *sub -= dt;    /* don't expire yet */
            t = *sub;
        } else {
            ret = 1;    /* single "true" return */
        }
    }

    /* didn't awake, but can be the smallest wclk */
    if ( (!ret) && (CEU_APP.wclk_min_set > t) ) {
        CEU_APP.wclk_min_set = t;
        ceu_callback_wclock_min(t, CEU_TRACE_null);
    }

    return ret;
}

__attribute__((__unused__))
static void ceu_params_cpy (tceu_stk* stk, void* params, usize params_n) {
    ceu_assert_sys(CEU_APP.stack_i+params_n < CEU_STACK_N, "stack overflow");
    memcpy(&CEU_APP.stack[CEU_APP.stack_i], params, params_n);
    stk->params   = &CEU_APP.stack[CEU_APP.stack_i];
    stk->params_n = params_n;
    CEU_APP.stack_i += stk->params_n;
}

/*****************************************************************************/

static void ceu_stack_clear (tceu_stk* cur, tceu_code_mem* mem) {
    if (cur == NULL) {
        return;
    }
    if (cur->range.mem == mem) {
        cur->is_alive = 0;
    }
    ceu_stack_clear(cur->prv, mem);
}

#ifdef CEU_FEATURES_POOL
static void ceu_code_mem_dyn_free (tceu_pool* pool, tceu_code_mem_dyn* cur) {
    cur->nxt->prv = cur->prv;
    cur->prv->nxt = cur->nxt;

#ifdef CEU_FEATURES_DYNAMIC
    if (pool->queue == NULL) {
        /* dynamic pool */
        ceu_callback_free(cur, CEU_TRACE_null);
    } else
#endif
    {
        /* static pool */
        ceu_pool_free(pool, (byte*)cur);
    }
}

static void ceu_code_mem_dyn_gc (tceu_pool_pak* pak) {
    if (pak->n_traversing == 0) {
        /* TODO-OPT: one element killing another is unlikely:
                     set bit in pool when this happens and only
                     traverses in this case */
        tceu_code_mem_dyn* cur = pak->first.nxt;
        while (cur != &pak->first) {
            tceu_code_mem_dyn* nxt = cur->nxt;
            if (!cur->is_alive) {
                ceu_code_mem_dyn_free(&pak->pool, cur);
            }
            cur = nxt;
        }
    }
}
#endif

/*****************************************************************************/

#ifdef CEU_FEATURES_LUA
static void ceu_lua_createargtable (lua_State* lua, char** argv, int argc, int script) {
    int i, narg;
    if (script == argc) script = 0;  /* no script name? */
    narg = argc - (script + 1);  /* number of positive indices */
    lua_createtable(lua, narg, script + 1);
    for (i = 0; i < argc; i++) {
        lua_pushstring(lua, argv[i]);
        lua_rawseti(lua, -2, i - script);
    }
    lua_setglobal(lua, "arg");
}

#endif

/*****************************************************************************/

static int ceu_lbl (tceu_nstk _ceu_level, tceu_stk* _ceu_cur, tceu_stk* _ceu_nxt, tceu_code_mem* _ceu_mem, tceu_nlbl _ceu_lbl, tceu_ntrl* _ceu_trlK);


    tceu_vector* usart_tx_buf;
    usize usart_tx_buf_i;

#define PURIFY(e) e


static tceu_nlbl CEU_CODE_USART_Init_to_lbl (tceu_code_mem_USART_Init* mem)
{
    tceu_nlbl lbl = CEU_LABEL_Code_USART_Init;
    return lbl;
}
static tceu_nlbl CEU_CODE_USART_Tx_to_lbl (tceu_code_mem_USART_Tx* mem)
{
    tceu_nlbl lbl = CEU_LABEL_Code_USART_Tx;
    return lbl;
}
static bool /* space */
CEU_CODE_INT0_Get (tceu_code_mem_INT0_Get mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_INT0_Get* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_INT0_Get;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}
static none /* space */
CEU_CODE_String_Check (tceu_code_mem_String_Check mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Check* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Check;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Print (tceu_code_mem_String_Print mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Print* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Print;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Append_STR (tceu_code_mem_String_Append_STR mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Append_STR* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Append_STR;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Append_INT (tceu_code_mem_String_Append_INT mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Append_INT* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Append_INT;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static none /* space */
CEU_CODE_String_Append_REAL (tceu_code_mem_String_Append_REAL mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Append_REAL* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Append_REAL;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
}
static bool /* space */
CEU_CODE_String_Equal (tceu_code_mem_String_Equal mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Equal* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Equal;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}
static bool /* space */
CEU_CODE_String_Equal_STR (tceu_code_mem_String_Equal_STR mem_,
                         tceu_code_mem* up_mem
#ifdef CEU_FEATURES_TRACE
                      , tceu_trace trace
#endif
#ifdef CEU_FEATURES_LUA
                      , lua_State* lua
#endif
                        )
{
    tceu_code_mem_String_Equal_STR* mem = &mem_;
    mem_._mem.up_mem = up_mem;
    mem_._mem.depth  = 0;
#ifdef CEU_FEATURES_TRACE
    mem_._mem.trace = trace;
#endif
#ifdef CEU_FEATURES_LUA
    mem_._mem.lua = lua;
#endif
    tceu_nlbl lbl = CEU_LABEL_Code_String_Equal_STR;
    ceu_lbl(0, NULL, NULL, (tceu_code_mem*)mem, lbl, 0);
    return mem_._ret;
}




typedef struct tceu_isr_mem_62 {
    struct {
union {
struct {
union {
};
};
struct {
union {
};
};
};
};
} tceu_isr_mem_62;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(USART_TX_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_62 _ceu_loc;
    
/* Block (n=61, ln=41) */

#line 41 "./libraries/driver-usart/avr/usart.ceu"
{

/* If (n=59, ln=41) */

#line 41 "./libraries/driver-usart/avr/usart.ceu"
if (((usart_tx_buf_i)<(usart_tx_buf->len))) {
    
/* Block (n=53, ln=42) */

#line 42 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=50, ln=42) */

#line 42 "./libraries/driver-usart/avr/usart.ceu"
 UDR0 = *(byte*)(ceu_vector_geti(usart_tx_buf,usart_tx_buf_i)); 
/* Nat_Stmt (n=51, ln=43) */

#line 43 "./libraries/driver-usart/avr/usart.ceu"
 usart_tx_buf_i++; 
/* Block (n=53, ln=42) */

#line 42 "./libraries/driver-usart/avr/usart.ceu"
}
} else {
    
/* Block (n=58, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
{

/* Emit_Ext_emit (n=56, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
{

/* Emit_Ext_emit (n=56, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_TX_DONE,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(0, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_USART_TX_DONE,{NULL}}).id, NULL };
    ceu_callback_isr_emit(USART_TX_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=56, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=58, ln=45) */

#line 45 "./libraries/driver-usart/avr/usart.ceu"
}
}

/* Block (n=61, ln=41) */

#line 41 "./libraries/driver-usart/avr/usart.ceu"
}
}
typedef struct tceu_isr_mem_174 {
    struct {
union {
};
};
} tceu_isr_mem_174;

#ifndef CEU_ISR
#error Missing architecture definition for `CEU_ISR`.
#endif

CEU_ISR(INT0_vect)
{
    tceu_code_mem* _ceu_mem = &CEU_APP.root._mem;
    tceu_isr_mem_174 _ceu_loc;
    
/* Block (n=173, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Emit_Ext_emit (n=171, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Emit_Ext_emit (n=171, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
{
#ifdef CEU_FEATURES_ISR_STATIC
    tceu_isr_evt __ceu_evt = { ((tceu_evt){CEU_INPUT_INT0,{NULL}}).id, 0, NULL };
    ceu_callback_isr_emit(1, (void*)&__ceu_evt, CEU_TRACE(0));
#else
    tceu_evt_id_params __ceu_evt = { ((tceu_evt){CEU_INPUT_INT0,{NULL}}).id, NULL };
    ceu_callback_isr_emit(INT0_vect, (void*)&__ceu_evt, CEU_TRACE(0));
#endif
}

/* Emit_Ext_emit (n=171, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Block (n=173, ln=18) */

#line 18 "./libraries/driver-gpio/avr/int0.ceu"
}
}




/*****************************************************************************/

#ifdef CEU_FEATURES_EXCEPTION
static int ceu_throw_ex (tceu_catch* catches, tceu_data_Exception* exception, usize len
                  , tceu_nstk level, tceu_stk* nxt
#ifdef CEU_FEATURES_TRACE
                  , tceu_trace trace
#endif
                  )
{
    tceu_catch* cur = catches;
    while (cur != NULL) {
        if (ceu_data_is(CEU_DATA_SUPERS_Exception,exception->_enum,cur->exception->value._enum)) {
            //ceu_sys_assert(!cur->exception->is_set, "double catch");
            ceu_assert_ex(!cur->exception->is_set, "double catch", trace);
            cur->exception->is_set = 1;
            memcpy(&cur->exception->value, exception, len);

#if 0
            /* do not allow nested catches (and itself) to awake */
            cur->exception = NULL;
            while (catches != cur) {
                catches->exception = NULL;
                catches = catches->up;
            }
#endif

            //return ceu_lbl(NULL, stk, cur->mem, cur->trl, cur->mem->_trails[cur->trl].lbl);
            //return ceu_lbl(_ceu_level, _ceu_cur, _ceu_nxt, _ceu_mem, _ceu_lbl, _ceu_trlK)
            cur->mem->_trails[cur->trl].evt.id = CEU_INPUT__STACKED;
            cur->mem->_trails[cur->trl].level = level + 1;
//printf(">>> %d %d\n", cur->trl, cur->mem->_trails[cur->trl].lbl);
            tceu_evt   evt   = {CEU_INPUT__NONE, {NULL}};
            //tceu_range range = { cur->mem, cur->trl, cur->trl };
            tceu_range range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
            nxt->evt      = evt;
            nxt->range    = range;
            nxt->params_n = 0;
            return 1;
        }
        cur = cur->up;
    }
    ceu_assert_ex(0, exception->message, trace);
    return 0;
}
#ifdef CEU_FEATURES_TRACE
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_level,_ceu_nxt,CEU_TRACE(0))
#else
#define ceu_throw(a,b,c) ceu_throw_ex(a,b,c,_ceu_level,_ceu_nxt)
#endif
#endif

#ifdef CEU_FEATURES_THREAD
static int ceu_threads_gc (int force_join) {
    int n_alive = 0;
    CEU_APP.cur_ = &CEU_APP.threads_head;
    tceu_threads_data*  head  = *CEU_APP.cur_;
    while (head != NULL) {
        tceu_threads_data** nxt_ = &head->nxt;
        if (head->has_terminated || head->has_aborted)
        {
            if (!head->has_notified) {
                ceu_input(CEU_INPUT__THREAD, &head->id);
                head->has_notified = 1;
            }

            /* remove from list if rejoined */
            {
                int has_joined;
                if (force_join || head->has_terminated) {
                    CEU_THREADS_JOIN(head->id);
                    has_joined = 1;
                } else {
                    /* possible with "CANCEL" which prevents setting "has_terminated" */
                    has_joined = CEU_THREADS_JOIN_TRY(head->id);
                }
                if (has_joined) {
                    *CEU_APP.cur_ = head->nxt;
                    nxt_ = CEU_APP.cur_;
                    ceu_callback_free(head, CEU_TRACE_null);
                }
            }
        }
        else
        {
            n_alive++;
        }
        CEU_APP.cur_ = nxt_;
        head  = *CEU_APP.cur_;
    }
    return n_alive;
}
#endif

/*****************************************************************************/

#define CEU_GOTO(lbl) {_ceu_lbl=lbl; goto _CEU_LBL_;}

static int ceu_lbl (tceu_nstk _ceu_level, tceu_stk* _ceu_cur, tceu_stk* _ceu_nxt, tceu_code_mem* _ceu_mem, tceu_nlbl _ceu_lbl, tceu_ntrl* _ceu_trlK)
{
#define CEU_TRACE(n) ((tceu_trace){&_ceu_mem->trace,__FILE__,__LINE__+(n)})
#ifdef CEU_STACK_MAX
    {
        static void* base = NULL;
        if (base == NULL) {
            base = &_ceu_level;
        } else {
#if 0
#if 0
//Serial.begin(9600);
Serial.println((usize)base);
Serial.println((usize)&_ceu_lbl);
Serial.print(" lbl "); Serial.println(_ceu_lbl);
//Serial.flush();
    if((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_level)) {
    } else {
        delay(1000);
    }
#else
printf(">>> %p / %p / %ld\n", base, &_ceu_lbl, ((u64)base)-((u64)&_ceu_lbl));
printf("%ld %ld %d\n", (usize)(base-CEU_STACK_MAX), (usize)(&_ceu_level),
            ((usize)(base-CEU_STACK_MAX) <= (usize)(&_ceu_level)));
#endif
#endif
            ceu_assert((usize)(((byte*)base)-CEU_STACK_MAX) <= (usize)(&_ceu_level), "stack overflow");
        }
    }
#endif

_CEU_LBL_:
    //printf("-=-=- %d -=-=-\n", _ceu_lbl);
    switch (_ceu_lbl) {
        case CEU_LABEL_NONE:
            break;
        
/* ROOT (n=679, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_ROOT:;

/* Block (n=678, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Block (n=673, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Set_Exp (n=1404, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
((((CEU_APP.root.usart_lock)).is_locked)) = 0;

/* Set_Exp (n=36, ln=18) */

#line 18 "./libraries/driver-usart/avr/usart.ceu"
((CEU_APP.root.usart_pm_refs)) = 0;

/* Code (n=996, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=996, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_Code_USART_Init:;

/* Block (n=995, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
{

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Init_Par_Or_sub_2_IN_35;

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or_sub_1_IN_34);

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_1_IN_34:;

/* Finalize_Case (n=1710, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Init_Finalize_Case__IN_39;

/* Finalize_Case (n=1710, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=1710, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Finalize_Case__IN_39:;

/* Block (n=990, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
{

/* Code_Finalize (n=988, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
if (_ceu_mem->has_term) {
    /* generate only if terminating from inside */
    _ceu_mem->_trails[1].evt.id = CEU_INPUT__STACKED;
    _ceu_mem->_trails[1].level  = _ceu_level;
    _ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Init_Code_USART_Init__TERM_52;

    tceu_evt   __ceu_evt   = { CEU_INPUT__CODE_TERMINATED, {_ceu_mem} };
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;

/* Code_Finalize (n=988, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
_ceu_nxt->params_n = 0;

/* Code_Finalize (n=988, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
}

#ifdef CEU_FEATURES_POOL
if (_ceu_mem->pak != NULL) {
    tceu_code_mem_dyn* __ceu_dyn =
        (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));
    __ceu_dyn->is_alive = 0;
}
#endif

ceu_stack_clear(_ceu_cur, _ceu_mem);

if (_ceu_mem->has_term) {
    _ceu_mem->has_term = 0;
    return 1;
} else {
    return 0;
}

/* Code_Finalize (n=988, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Block (n=990, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=1710, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=1710, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=1878, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_36);

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_2_IN_35:;

/* Block (n=986, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=984, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=78, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=70, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"

        UCSR0A = 1 << U2X0;
        UBRR0H = (USART_BAUD((((*((tceu_code_mem_USART_Init*)_ceu_mem)).bps)))>>8); // set baud rate
        UBRR0L = (USART_BAUD((((*((tceu_code_mem_USART_Init*)_ceu_mem)).bps))));
        UCSR0C = (1<<USBS0) | (3<<UCSZ00); // 8data, 2stop-bit
        UCSR0B = (1<<RXEN0) | (1<<RXCIE0); // enables RX & ISRS
    
/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_USART_Init_Par_Or_sub_2_IN_41;

/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or_sub_1_IN_40);

/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_1_IN_40:;

/* Finalize_Case (n=1712, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_USART_Init_Finalize_Case__IN_45;

/* Finalize_Case (n=1712, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=1712, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Finalize_Case__IN_45:;

/* Block (n=73, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=71, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"

            UCSR0B = 0; // disables TX/RX & ISRS
        
/* Block (n=73, ln=62) */

#line 62 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=1712, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=1712, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=1884, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_42);

/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or_sub_2_IN_41:;

/* Await_Forever (n=76, ln=66) */

#line 66 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Nat_Stmt (n=1419, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
ceu_assert(0, "reached end of `code`");
/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_42);

/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__OUT_42:;

/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Init_Par_Or__CLR_43;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 2+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1887, ln=61) */

#line 61 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__CLR_43:;

/* Block (n=78, ln=54) */

#line 54 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=984, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=986, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
}

/* Do (n=987, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Do__OUT_49:;

/* Do (n=987, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
    _ceu_mem->has_term = 1;

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Init_Par_Or__OUT_36);

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__OUT_36:;

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_USART_Init_Par_Or__CLR_37;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 4 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1881, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Init_Par_Or__CLR_37:;

/* Block (n=995, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=996, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Code (n=996, ln=53) */

#line 53 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=1015, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1015, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_Code_USART_Tx:;

/* Block (n=1014, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
{

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_54;

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_53);

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_53:;

/* Finalize_Case (n=1714, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Tx_Finalize_Case__IN_58;

/* Finalize_Case (n=1714, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=1714, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Finalize_Case__IN_58:;

/* Block (n=1009, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
{

/* Code_Finalize (n=1007, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
if (_ceu_mem->has_term) {
    /* generate only if terminating from inside */
    _ceu_mem->_trails[1].evt.id = CEU_INPUT__STACKED;
    _ceu_mem->_trails[1].level  = _ceu_level;
    _ceu_mem->_trails[1].lbl    = CEU_LABEL_USART_Tx_Code_USART_Tx__TERM_93;

    tceu_evt   __ceu_evt   = { CEU_INPUT__CODE_TERMINATED, {_ceu_mem} };
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;

/* Code_Finalize (n=1007, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
_ceu_nxt->params_n = 0;

/* Code_Finalize (n=1007, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}

#ifdef CEU_FEATURES_POOL
if (_ceu_mem->pak != NULL) {
    tceu_code_mem_dyn* __ceu_dyn =
        (tceu_code_mem_dyn*)(((byte*)(_ceu_mem)) - sizeof(tceu_code_mem_dyn));
    __ceu_dyn->is_alive = 0;
}
#endif

ceu_stack_clear(_ceu_cur, _ceu_mem);

if (_ceu_mem->has_term) {
    _ceu_mem->has_term = 0;
    return 1;
} else {
    return 0;
}

/* Code_Finalize (n=1007, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Block (n=1009, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=1714, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=1714, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=1890, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or__OUT_55);

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_54:;

/* Block (n=1005, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=1003, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=139, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=1060, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
{

/* Loop (n=1037, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
while (1) {
        
/* Block (n=1036, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
{

/* If (n=1034, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
if (((((CEU_APP.root.usart_lock)).is_locked))) {
    
/* Block (n=1030, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
{

/* Await_Int (n=1027, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt = ((tceu_evt){ CEU_EVENT_LOCK_OK_UNLOCKED, {&((CEU_APP.root.usart_lock))} });

/* Await_Int (n=1027, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].lbl = CEU_LABEL_USART_Tx_Await_ok_unlocked__OUT_59;

/* Await_Int (n=1027, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Await_Int (n=1027, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Await_ok_unlocked__OUT_59:;

/* Block (n=1030, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
}
} else {
    
/* Block (n=1033, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
{

/* Break (n=1031, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Loop_Break__OUT_66);

/* Block (n=1033, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
}
}

/* Block (n=1036, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
}

/* Loop (n=1037, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Loop_Continue__CNT_64:;

/* Loop (n=1037, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
        *_ceu_trlK = 1;
}

/* Loop (n=1037, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Loop_Break__OUT_66:;

/* Set_Exp (n=1043, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
((((CEU_APP.root.usart_lock)).is_locked)) = 1;

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_68;

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_67);

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_67:;

/* Finalize_Case (n=1716, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_USART_Tx_Finalize_Case__IN_73;

/* Finalize_Case (n=1716, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=1716, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Finalize_Case__IN_73:;

/* Block (n=1057, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
{

/* Set_Exp (n=1049, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
((((CEU_APP.root.usart_lock)).is_locked)) = 0;

/* Emit_Evt (n=1055, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[3].level  = _ceu_level;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_USART_Tx_Emit_Int__OUT_71;
{
    tceu_evt   __ceu_evt   = ((tceu_evt){ CEU_EVENT_LOCK_OK_UNLOCKED, {&((CEU_APP.root.usart_lock))} });
    tceu_range __ceu_range = { &CEU_APP.root._mem, 0, CEU_TRAILS_N-1 };
    _ceu_nxt->evt     = __ceu_evt;
    _ceu_nxt->range   = __ceu_range;

/* Emit_Evt (n=1055, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
    _ceu_nxt->params_n = 0;

/* Emit_Evt (n=1055, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
    return 1;
}

/* Emit_Evt (n=1055, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Emit_Int__OUT_71:;

/* Block (n=1057, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=1716, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=1716, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=1896, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or__OUT_69);

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_68:;

/* Block (n=136, ln=72) */

#line 72 "./libraries/driver-usart/avr/usart.ceu"
{

/* Set_Exp (n=98, ln=72) */

#line 72 "./libraries/driver-usart/avr/usart.ceu"
((CEU_APP.root.usart_pm_refs)) = (((CEU_APP.root.usart_pm_refs))+1);

/* Nat_Stmt (n=102, ln=73) */

#line 73 "./libraries/driver-usart/avr/usart.ceu"

            ceu_pm_set(CEU_PM_USART, 1);
            ceu_assert(bitRead(UCSR0A,UDRE0)==1, "pending TX?");
            ceu_assert(bitRead(UCSR0A,TXC0)==0, "pending ISR?");
            usart_tx_buf = ((((*((tceu_code_mem_USART_Tx*)_ceu_mem)).buf))); // safe because finalize disables TX
            usart_tx_buf_i = 1;
            UCSR0B |= (1<<TXEN0) | (1<<TXCIE0); // enables  TX & ISR
        
/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[6].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[6].level  = _ceu_level;
_ceu_mem->_trails[6].lbl    = CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_75;

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_74);

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or_sub_1_IN_74:;

/* Finalize_Case (n=1718, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[5].evt.id = CEU_INPUT__FINALIZE;
_ceu_mem->_trails[5].lbl    = CEU_LABEL_USART_Tx_Finalize_Case__IN_81;

/* Finalize_Case (n=1718, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
if (0) {

/* Finalize_Case (n=1718, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Finalize_Case__IN_81:;

/* Block (n=122, ln=82) */

#line 82 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=103, ln=82) */

#line 82 "./libraries/driver-usart/avr/usart.ceu"

                UCSR0B &= ~((1<<TXEN0) | (1<<TXCIE0)); // disables TX & ISR
            
/* Set_Exp (n=111, ln=85) */

#line 85 "./libraries/driver-usart/avr/usart.ceu"
((CEU_APP.root.usart_pm_refs)) = (((CEU_APP.root.usart_pm_refs))-1);

/* If (n=120, ln=86) */

#line 86 "./libraries/driver-usart/avr/usart.ceu"
if ((((CEU_APP.root.usart_pm_refs))==0)) {
    
/* Block (n=119, ln=87) */

#line 87 "./libraries/driver-usart/avr/usart.ceu"
{

/* Nat_Stmt (n=117, ln=87) */

#line 87 "./libraries/driver-usart/avr/usart.ceu"
ceu_pm_set(CEU_PM_USART, 0);
/* Block (n=119, ln=87) */

#line 87 "./libraries/driver-usart/avr/usart.ceu"
}
} else {
    
/* Block (n=1064, ln=86) */

#line 86 "./libraries/driver-usart/avr/usart.ceu"
{

/* Block (n=1064, ln=86) */

#line 86 "./libraries/driver-usart/avr/usart.ceu"
}
}

/* Block (n=122, ln=82) */

#line 82 "./libraries/driver-usart/avr/usart.ceu"
}

/* Finalize_Case (n=1718, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Finalize_Case (n=1718, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
}

/* Await_Forever (n=1902, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or__OUT_76);

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or_sub_2_IN_75:;

/* Set_Exp (n=129, ln=91) */

#line 91 "./libraries/driver-usart/avr/usart.ceu"
UDR0 = (*(byte*) ceu_vector_geti((((*((tceu_code_mem_USART_Tx*)_ceu_mem)).buf)),0))
;

/* Await_Ext (n=133, ln=92) */

#line 92 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[6].evt = ((tceu_evt){CEU_INPUT_USART_TX_DONE,{NULL}});

/* Await_Ext (n=133, ln=92) */

#line 92 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[6].lbl = CEU_LABEL_USART_Tx_Await_USART_TX_DONE__OUT_82;

/* Await_Ext (n=133, ln=92) */

#line 92 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Await_Ext (n=133, ln=92) */

#line 92 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Await_USART_TX_DONE__OUT_82:;

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or__OUT_76);

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or__OUT_76:;

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[4].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[4].level  = _ceu_level;
_ceu_mem->_trails[4].lbl    = CEU_LABEL_USART_Tx_Par_Or__CLR_77;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 4+1, 6 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1905, ln=81) */

#line 81 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or__CLR_77:;

/* Block (n=136, ln=72) */

#line 72 "./libraries/driver-usart/avr/usart.ceu"
}

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or__OUT_69);

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or__OUT_69:;

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[2].level  = _ceu_level;
_ceu_mem->_trails[2].lbl    = CEU_LABEL_USART_Tx_Par_Or__CLR_70;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 2+1, 6 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1899, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or__CLR_70:;

/* Block (n=1060, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
}

/* Do (n=1061, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Do__OUT_85:;

/* Block (n=139, ln=71) */

#line 71 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=1003, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}

/* Block (n=1005, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}

/* Do (n=1006, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Do__OUT_90:;

/* Do (n=1006, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
    _ceu_mem->has_term = 1;

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
CEU_GOTO(CEU_LABEL_USART_Tx_Par_Or__OUT_55);

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or__OUT_55:;

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
_ceu_mem->_trails[0].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[0].level  = _ceu_level;
_ceu_mem->_trails[0].lbl    = CEU_LABEL_USART_Tx_Par_Or__CLR_56;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 0+1, 6 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1893, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
case CEU_LABEL_USART_Tx_Par_Or__CLR_56:;

/* Block (n=1014, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=1015, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
return 0;

/* Code (n=1015, ln=69) */

#line 69 "./libraries/driver-usart/avr/usart.ceu"
}

/* Code (n=1082, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1082, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
case CEU_LABEL_Code_INT0_Get:;

/* Block (n=1081, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Block (n=1073, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Block (n=1071, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Block (n=161, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
{

/* Set_Exp (n=1083, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
(((*((tceu_code_mem_INT0_Get*)_ceu_mem))._ret)) = (((bool)((((bool)(digitalRead(2)))? 1 : 0)))? 1 : 0);

/* Escape (n=159, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
CEU_GOTO(CEU_LABEL_INT0_Get_Do__OUT_97);

/* Block (n=161, ln=6) */

#line 6 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Block (n=1071, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Block (n=1073, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Do (n=1074, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=1074, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
case CEU_LABEL_INT0_Get_Do__OUT_97:;

/* Block (n=1081, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Code (n=1082, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
return 0;

/* Code (n=1082, ln=5) */

#line 5 "./libraries/driver-gpio/avr/int0.ceu"
}

/* Nat_Stmt (n=165, ln=11) */

#line 11 "./libraries/driver-gpio/avr/int0.ceu"

    pinMode(2, INPUT_PULLUP);
    EICRA = (EICRA & ~((1<<ISC00) | (1<<ISC01))) | (CHANGE << ISC00);
    EIMSK |= (1 << INT0);

/* Code (n=1267, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1267, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Check:;

/* Block (n=1266, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1262, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1260, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=234, ln=75) */

#line 75 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=200, ln=75) */

#line 75 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert((((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).max)>0),"dynamic vector is not supported");

/* If (n=232, ln=76) */

#line 76 "/home/anny/dev/ceu/include/string.ceu"
if ((((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len)>0)) {
    
/* Block (n=219, ln=77) */

#line 77 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=217, ln=77) */

#line 77 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(((*(byte*) ceu_vector_geti((((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)),(((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len)-1)))
==('\0')),"invalid string");

/* Block (n=219, ln=77) */

#line 77 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=231, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Vec (n=228, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=228, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    __ceu_nxt = (*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len;

/* Set_Vec (n=228, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    __ceu_nxt = (*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len;

/* Set_Vec (n=228, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    ceu_vector_setlen(&(*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)), ((*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)).len + 1), 1);

/* Set_Vec (n=228, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
    *((byte*)
        ceu_vector_buf_get(&(*((*((tceu_code_mem_String_Check*)_ceu_mem)).dst)), __ceu_nxt++)) = ('\0');

/* Set_Vec (n=228, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"

/* Set_Vec (n=228, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=231, ln=79) */

#line 79 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Block (n=234, ln=75) */

#line 75 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1260, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1262, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1263, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Check_Do__OUT_109:;

/* Block (n=1266, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1267, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1267, ln=74) */

#line 74 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1281, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1281, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Print:;

/* Block (n=1280, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1276, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1274, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=253, ln=84) */

#line 84 "/home/anny/dev/ceu/include/string.ceu"
{

/* Nat_Stmt (n=251, ln=84) */

#line 84 "/home/anny/dev/ceu/include/string.ceu"

        const char* strC = ((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Print*)_ceu_mem)).str)),0))
)));
        printf("%s", strC);
    
/* Block (n=253, ln=84) */

#line 84 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1274, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1276, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1277, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Print_Do__OUT_117:;

/* Block (n=1280, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1281, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1281, ln=83) */

#line 83 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1295, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1295, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Append_STR:;

/* Block (n=1294, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1290, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1288, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=311, ln=91) */

#line 91 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=272, ln=91) */

#line 91 "/home/anny/dev/ceu/include/string.ceu"
CEU_CODE_String_Check(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Check __ceu_270;__ceu_270.dst = ((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)));; __ceu_270;})

#else
(tceu_code_mem_String_Check) { .dst = ((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst))) }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Stmt_Call (n=295, ln=92) */

#line 92 "/home/anny/dev/ceu/include/string.ceu"
strncat(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)),0))
))),((char*)((&((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).src))[0])))),(((*((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)).max)-((*((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)).len)));

/* Stmt_Call (n=309, ln=93) */

#line 93 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst))),(((*((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).dst)).len)+strlen((((*((tceu_code_mem_String_Append_STR*)_ceu_mem)).src)))),1);

/* Block (n=311, ln=91) */

#line 91 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1288, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1290, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1291, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Append_STR_Do__OUT_125:;

/* Block (n=1294, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1295, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1295, ln=90) */

#line 90 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1310, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1310, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Append_INT:;

/* Block (n=1309, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1305, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1303, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=397, ln=97) */

#line 97 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=333, ln=97) */

#line 97 "/home/anny/dev/ceu/include/string.ceu"
CEU_CODE_String_Check(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Check __ceu_331;__ceu_331.dst = ((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)));; __ceu_331;})

#else
(tceu_code_mem_String_Check) { .dst = ((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst))) }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Set_Exp (n=341, ln=99) */

#line 99 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(&(*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)),(((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)-1), 0);

/* If (n=353, ln=101) */

#line 101 "/home/anny/dev/ceu/include/string.ceu"
if ((!((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)).is_set))) {
    
/* Block (n=352, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=349, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)).is_set = 1;

/* Set_Exp (n=349, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)).value) = 10;

/* Block (n=352, ln=102) */

#line 102 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=1315, ln=101) */

#line 101 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1315, ln=101) */

#line 101 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Set_Exp (n=375, ln=105) */

#line 105 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).n)) = ceu_itona((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).src)),((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)),((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)))
))),(CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).base)), CEU_TRACE(0))->value),(((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).max)-((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)));

/* Stmt_Call (n=384, ln=106) */

#line 106 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).n))>0),"access out of bounds");

/* Stmt_Call (n=395, ln=107) */

#line 107 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(((((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst))),(((*((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).dst)).len)+(((*((tceu_code_mem_String_Append_INT*)_ceu_mem)).n))),1);

/* Block (n=397, ln=97) */

#line 97 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1303, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1305, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1306, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Append_INT_Do__OUT_135:;

/* Block (n=1309, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1310, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1310, ln=96) */

#line 96 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1332, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1332, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Append_REAL:;

/* Block (n=1331, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1327, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1325, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=477, ln=111) */

#line 111 "/home/anny/dev/ceu/include/string.ceu"
{

/* Stmt_Call (n=419, ln=111) */

#line 111 "/home/anny/dev/ceu/include/string.ceu"
CEU_CODE_String_Check(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Check __ceu_417;__ceu_417.dst = ((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)));; __ceu_417;})

#else
(tceu_code_mem_String_Check) { .dst = ((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst))) }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* If (n=430, ln=113) */

#line 113 "/home/anny/dev/ceu/include/string.ceu"
if ((!((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)).is_set))) {
    
/* Block (n=429, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=426, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)).is_set = 1;

/* Set_Exp (n=426, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)).value) = 2;

/* Block (n=429, ln=114) */

#line 114 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=1337, ln=113) */

#line 113 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1337, ln=113) */

#line 113 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Stmt_Call (n=439, ln=117) */

#line 117 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(((CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)), CEU_TRACE(0))->value)<999),"precision error");

/* Nat_Stmt (n=442, ln=119) */

#line 119 "/home/anny/dev/ceu/include/string.ceu"

        char format[6];
        sprintf(format, "%%.%df", (CEU_OPTION_tceu_opt_int(&(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).precision)), CEU_TRACE(0))->value));
    
/* Stmt_Call (n=455, ln=124) */

#line 124 "/home/anny/dev/ceu/include/string.ceu"
sprintf(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)),0))
))),(format),(((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).src)));

/* Stmt_Call (n=475, ln=126) */

#line 126 "/home/anny/dev/ceu/include/string.ceu"
ceu_vector_setlen(((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst))),(((*((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)).len)+strlen(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Append_REAL*)_ceu_mem)).dst)),0))
))))),1);

/* Block (n=477, ln=111) */

#line 111 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1325, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1327, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1328, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Append_REAL_Do__OUT_145:;

/* Block (n=1331, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1332, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1332, ln=110) */

#line 110 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1354, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1354, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Equal:;

/* Block (n=1353, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1345, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1343, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=524, ln=132) */

#line 132 "/home/anny/dev/ceu/include/string.ceu"
{

/* Nat_Stmt (n=510, ln=133) */

#line 133 "/home/anny/dev/ceu/include/string.ceu"

        (((*((tceu_code_mem_String_Equal*)_ceu_mem)).result))= strcmp(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Equal*)_ceu_mem)).str1)),0))
))), ((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Equal*)_ceu_mem)).str2)),0))
))));
    
/* If (n=522, ln=137) */

#line 137 "/home/anny/dev/ceu/include/string.ceu"
if (((((*((tceu_code_mem_String_Equal*)_ceu_mem)).result))==0)) {
    
/* Block (n=517, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1361, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal*)_ceu_mem))._ret)) = 1;

/* Escape (n=515, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_Do__OUT_155);

/* Block (n=517, ln=138) */

#line 138 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=521, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1362, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal*)_ceu_mem))._ret)) = 0;

/* Escape (n=519, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_Do__OUT_155);

/* Block (n=521, ln=140) */

#line 140 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Block (n=524, ln=132) */

#line 132 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1343, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1345, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1346, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=1346, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Equal_Do__OUT_155:;

/* Block (n=1353, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1354, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1354, ln=131) */

#line 131 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1379, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
/* do not enter from outside */
if (0)
{

/* Code (n=1379, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_Code_String_Equal_STR:;

/* Block (n=1378, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1370, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=1368, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
{

/* Block (n=571, ln=145) */

#line 145 "/home/anny/dev/ceu/include/string.ceu"
{

/* Nat_Stmt (n=557, ln=146) */

#line 146 "/home/anny/dev/ceu/include/string.ceu"

        (((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).result))= strcmp(((char*)((((byte*) ceu_vector_buf_get((((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).str1)),0))
))), ((char*)((&((((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).str2))[0])))));
    
/* If (n=569, ln=150) */

#line 150 "/home/anny/dev/ceu/include/string.ceu"
if (((((*((tceu_code_mem_String_Equal_STR*)_ceu_mem)).result))==0)) {
    
/* Block (n=564, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1386, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal_STR*)_ceu_mem))._ret)) = 1;

/* Escape (n=562, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_STR_Do__OUT_165);

/* Block (n=564, ln=151) */

#line 151 "/home/anny/dev/ceu/include/string.ceu"
}
} else {
    
/* Block (n=568, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
{

/* Set_Exp (n=1387, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
(((*((tceu_code_mem_String_Equal_STR*)_ceu_mem))._ret)) = 0;

/* Escape (n=566, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
CEU_GOTO(CEU_LABEL_String_Equal_STR_Do__OUT_165);

/* Block (n=568, ln=153) */

#line 153 "/home/anny/dev/ceu/include/string.ceu"
}
}

/* Block (n=571, ln=145) */

#line 145 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1368, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Block (n=1370, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Do (n=1371, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=1371, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
case CEU_LABEL_String_Equal_STR_Do__OUT_165:;

/* Block (n=1378, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Code (n=1379, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
return 0;

/* Code (n=1379, ln=144) */

#line 144 "/home/anny/dev/ceu/include/string.ceu"
}

/* Loop (n=634, ln=5) */

#line 5 "libraries/driver-gpio/examples/out-01.ceu"
while (1) {
        
/* Block (n=633, ln=6) */

#line 6 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Await_Ext (n=576, ln=6) */

#line 6 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[1].evt = ((tceu_evt){CEU_INPUT_INT0,{NULL}});

/* Await_Ext (n=576, ln=6) */

#line 6 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[1].lbl = CEU_LABEL_Await_INT0__OUT_170;

/* Await_Ext (n=576, ln=6) */

#line 6 "libraries/driver-gpio/examples/out-01.ceu"
return 0;

/* Await_Ext (n=576, ln=6) */

#line 6 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_INT0__OUT_170:;

/* Block (n=630, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[3].level  = _ceu_level;
_ceu_mem->_trails[3].lbl    = CEU_LABEL_Par_Or_sub_2_IN_172;

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or_sub_1_IN_171);

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_1_IN_171:;

/* Abs_Spawn (n=582, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[2].evt.id = CEU_INPUT__PROPAGATE_CODE;

/* Abs_Spawn (n=582, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[2].evt.mem = (tceu_code_mem*) &(CEU_APP.root.__mem_582);

/* Abs_Spawn (n=582, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[2].lbl = CEU_LABEL_Await_Spawn__OUT_175;

/* Abs_Spawn (n=582, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
{
    *((tceu_code_mem_USART_Init*)(&(CEU_APP.root. __mem_582))) = 
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_USART_Init __ceu_581;__ceu_581.bps = 9600;; __ceu_581;})

#else
(tceu_code_mem_USART_Init) { .bps = 9600 }

#endif
;
#ifdef CEU_FEATURES_POOL
    (&(CEU_APP.root. __mem_582))->_mem.pak    = NULL;
#endif
    (&(CEU_APP.root. __mem_582))->_mem.up_mem = _ceu_mem;
    (&(CEU_APP.root. __mem_582))->_mem.depth  = 0;
    (&(CEU_APP.root. __mem_582))->_mem.has_term = 0;
    (&(CEU_APP.root. __mem_582))->_mem.trails_n = 5;
    memset(&(&(CEU_APP.root. __mem_582))->_mem._trails, 0, 5*sizeof(tceu_trl));
    (&(CEU_APP.root. __mem_582))->_mem._trails[0].evt.id = CEU_INPUT__STACKED;
    (&(CEU_APP.root. __mem_582))->_mem._trails[0].level  = _ceu_level+1;
    (&(CEU_APP.root. __mem_582))->_mem._trails[0].lbl    = CEU_CODE_USART_Init_to_lbl((&(CEU_APP.root. __mem_582)));
}

{
    tceu_evt   __ceu_evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range __ceu_range = { (tceu_code_mem*)(&(CEU_APP.root. __mem_582)), 0, 5-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    //return 1; (later, after deciding for spawn/await)
}

/* Abs_Spawn (n=582, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
return 1;

/* Abs_Spawn (n=582, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_Spawn__OUT_175:;

/* Await_Forever (n=1908, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
return 0;

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_173);

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or_sub_2_IN_172:;

/* Set_Exp (n=589, ln=11) */

#line 11 "libraries/driver-gpio/examples/out-01.ceu"
((CEU_APP.root.v_590)) = CEU_CODE_INT0_Get(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_INT0_Get __ceu_587;; __ceu_587;})

#else
(tceu_code_mem_INT0_Get) {  }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Vec_Init (n=1681, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
ceu_vector_init(&((CEU_APP.root.str_597)),2, 0, 0, sizeof(byte),
                (byte*)&((CEU_APP.root.str_597_buf)));

/* Set_Vec (n=596, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
{
    usize __ceu_nxt;

/* Set_Vec (n=596, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
    ceu_vector_setlen(&((CEU_APP.root.str_597)), 0, 0);
    __ceu_nxt = 0;

/* Set_Vec (n=596, ln=13) */

#line 13 "libraries/driver-gpio/examples/out-01.ceu"
}

/* If (n=621, ln=14) */

#line 14 "libraries/driver-gpio/examples/out-01.ceu"
if ((((CEU_APP.root.v_590))==1)) {
    
/* Block (n=610, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Stmt_Call (n=608, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
CEU_CODE_String_Append_STR(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Append_STR __ceu_606;__ceu_606.dst = (&((CEU_APP.root.str_597)));__ceu_606.src = "1";; __ceu_606;})

#else
(tceu_code_mem_String_Append_STR) { .dst = (&((CEU_APP.root.str_597))),.src = "1" }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Block (n=610, ln=15) */

#line 15 "libraries/driver-gpio/examples/out-01.ceu"
}
} else {
    
/* Block (n=620, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
{

/* Stmt_Call (n=618, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
CEU_CODE_String_Append_STR(
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_String_Append_STR __ceu_616;__ceu_616.dst = (&((CEU_APP.root.str_597)));__ceu_616.src = "0";; __ceu_616;})

#else
(tceu_code_mem_String_Append_STR) { .dst = (&((CEU_APP.root.str_597))),.src = "0" }

#endif
,((tceu_code_mem*)_ceu_mem))
;

/* Block (n=620, ln=17) */

#line 17 "libraries/driver-gpio/examples/out-01.ceu"
}
}

/* Abs_Await (n=628, ln=19) */

#line 19 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].evt.id = CEU_INPUT__PROPAGATE_CODE;

/* Abs_Await (n=628, ln=19) */

#line 19 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].evt.mem = (tceu_code_mem*) &(CEU_APP.root.__mem_628);

/* Abs_Await (n=628, ln=19) */

#line 19 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[3].lbl = CEU_LABEL_Await_Await__OUT_178;

/* Abs_Await (n=628, ln=19) */

#line 19 "libraries/driver-gpio/examples/out-01.ceu"
{
    *((tceu_code_mem_USART_Tx*)(&(CEU_APP.root. __mem_628))) = 
#if defined(__GNUC__) && defined(__cplusplus)
({tceu_code_mem_USART_Tx __ceu_626;__ceu_626.buf = (&((CEU_APP.root.str_597)));; __ceu_626;})

#else
(tceu_code_mem_USART_Tx) { .buf = (&((CEU_APP.root.str_597))) }

#endif
;
#ifdef CEU_FEATURES_POOL
    (&(CEU_APP.root. __mem_628))->_mem.pak    = NULL;
#endif
    (&(CEU_APP.root. __mem_628))->_mem.up_mem = _ceu_mem;
    (&(CEU_APP.root. __mem_628))->_mem.depth  = 0;
    (&(CEU_APP.root. __mem_628))->_mem.has_term = 0;
    (&(CEU_APP.root. __mem_628))->_mem.trails_n = 7;
    memset(&(&(CEU_APP.root. __mem_628))->_mem._trails, 0, 7*sizeof(tceu_trl));
    (&(CEU_APP.root. __mem_628))->_mem._trails[0].evt.id = CEU_INPUT__STACKED;
    (&(CEU_APP.root. __mem_628))->_mem._trails[0].level  = _ceu_level+1;
    (&(CEU_APP.root. __mem_628))->_mem._trails[0].lbl    = CEU_CODE_USART_Tx_to_lbl((&(CEU_APP.root. __mem_628)));
}

{
    tceu_evt   __ceu_evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range __ceu_range = { (tceu_code_mem*)(&(CEU_APP.root. __mem_628)), 0, 7-1 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    //return 1; (later, after deciding for spawn/await)
}

/* Abs_Await (n=628, ln=19) */

#line 19 "libraries/driver-gpio/examples/out-01.ceu"
return 1;

/* Abs_Await (n=628, ln=19) */

#line 19 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Await_Await__OUT_178:;

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
CEU_GOTO(CEU_LABEL_Par_Or__OUT_173);

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__OUT_173:;

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
_ceu_mem->_trails[1].evt.id = CEU_INPUT__STACKED;
_ceu_mem->_trails[1].level  = _ceu_level;
_ceu_mem->_trails[1].lbl    = CEU_LABEL_Par_Or__CLR_174;
{
    tceu_evt   __ceu_evt   = {CEU_INPUT__CLEAR,{NULL}};
    tceu_range __ceu_range = { _ceu_mem, 1+1, 6 };
    _ceu_nxt->evt      = __ceu_evt;
    _ceu_nxt->range    = __ceu_range;
    _ceu_nxt->params_n = 0;
    return 1;
}

/* Par_Or (n=1911, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Par_Or__CLR_174:;

/* Block (n=630, ln=9) */

#line 9 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Do (n=631, ln=8) */

#line 8 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Do__OUT_180:;

/* Block (n=633, ln=6) */

#line 6 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Loop (n=634, ln=5) */

#line 5 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Continue__CNT_184:;

/* Loop (n=634, ln=5) */

#line 5 "libraries/driver-gpio/examples/out-01.ceu"
        *_ceu_trlK = -1;
}

/* Loop (n=634, ln=5) */

#line 5 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Loop_Break__OUT_186:;

/* Block (n=673, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
}

/* Do (n=674, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
ceu_assert(0, "reached end of `do`");

/* Do (n=674, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
case CEU_LABEL_Do__OUT_188:;

/* Block (n=678, ln=1) */

#line 1 "libraries/driver-gpio/examples/out-01.ceu"
}

    }
    //ceu_assert(0, "unreachable code");
    return 0;
#undef CEU_TRACE
}

#if defined(_CEU_DEBUG)
#define _CEU_DEBUG
static int xxx = 0;
#endif

static void ceu_bcast_mark (tceu_nstk level, tceu_stk* cur)
{
    tceu_ntrl trlK = cur->range.trl0;

    for (; trlK<=cur->range.trlF; trlK++)
    {
        tceu_trl* trl = &cur->range.mem->_trails[trlK];

        //printf(">>> mark [%d/%p] evt=%d\n", trlK, trl, trl->evt.id);
#ifdef CEU_TESTS
        _ceu_tests_trails_visited_++;
#endif
        switch (trl->evt.id)
        {
#ifdef CEU_FEATURES_POOL
            case CEU_INPUT__PROPAGATE_POOL: {
                tceu_code_mem_dyn* v = trl->evt.pak->first.nxt;
                while (v != &trl->evt.pak->first) {
                    tceu_range range_ = { &v->mem[0],
                                          0, (tceu_ntrl)((&v->mem[0])->trails_n-1) };
                    tceu_stk cur_ = *cur;
                    cur_.range = range_;
                    ceu_bcast_mark(level, &cur_);
                    v = v->nxt;
                }
                break;
            }
#endif

#ifdef CEU_FEATURES_PAUSE
            case CEU_INPUT__PAUSE_BLOCK: {
                u8 was_paused = trl->pse_paused;
                if ( (cur->evt.id == trl->pse_evt.id)                               &&
                     (cur->evt.id<CEU_EVENT__MIN || cur->evt.mem==trl->pse_evt.mem) &&
                     (*((u8*)cur->params) != trl->pse_paused) )
                {
                    trl->pse_paused = *((u8*)cur->params);

                    tceu_evt evt_;
                    tceu_range range_ = { cur->range.mem,
                                          (tceu_ntrl)(trlK+1), (tceu_ntrl)(trlK+trl->pse_skip) };
                    if (trl->pse_paused) {
                        evt_.id = CEU_INPUT__PAUSE;
                    } else {
                        CEU_APP.wclk_min_set = 0;   /* maybe resuming a timer, let it be the minimum set */
                        evt_.id = CEU_INPUT__RESUME;
                    }
                    tceu_stk cur_ = { evt_, range_, NULL, 0 };
                    ceu_bcast_mark(level, &cur_);
                }
                /* don't skip if pausing now */
                if (was_paused && cur->evt.id!=CEU_INPUT__CLEAR) {
                                  /* also don't skip on CLEAR (going reverse) */
                    trlK += trl->pse_skip;
                }
                break;
            }
#endif

            case CEU_INPUT__PROPAGATE_CODE: {
#if 0
                // TODO: simple optimization that could be done
                //          - do it also for POOL?
                if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && occ->params==trl->evt.mem ) {
                    // dont propagate when I am terminating
                } else
#endif
                tceu_range range_ = {
                    (tceu_code_mem*)trl->evt.mem,
                    0,
                    (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1)
                };
                tceu_stk cur_ = *cur;
                cur_.range = range_;
                ceu_bcast_mark(level, &cur_);
                //break;    (may awake from CODE_TERMINATED)
            }

            default: {
                if (cur->evt.id == CEU_INPUT__CLEAR) {
                    if (trl->evt.id == CEU_INPUT__FINALIZE) {
//printf("AWK %d %d\n", trlK, trl->lbl);
                        goto _CEU_AWAKE_YES_;
                    }
                } else if (cur->evt.id==CEU_INPUT__CODE_TERMINATED && trl->evt.id==CEU_INPUT__PROPAGATE_CODE) {
//printf("TERM %d %d\n", trlK, trl->lbl);
                    if (trl->evt.mem == cur->evt.mem) {
                        goto _CEU_AWAKE_YES_;
                    }
                } else if (trl->evt.id == cur->evt.id) {
#ifdef CEU_FEATURES_PAUSE
                    if (cur->evt.id==CEU_INPUT__PAUSE || cur->evt.id==CEU_INPUT__RESUME) {
                        goto _CEU_AWAKE_YES_;
                    }
#endif
                    if (trl->evt.id>CEU_EVENT__MIN || trl->evt.id==CEU_INPUT__CODE_TERMINATED) {
                        if (trl->evt.mem == cur->evt.mem) {
                            goto _CEU_AWAKE_YES_;   /* internal event matches "mem" */
                        }
                    } else {
                        if (cur->evt.id != CEU_INPUT__NONE) {
                            goto _CEU_AWAKE_YES_;       /* external event matches */
                        }
                    }
                }

                continue;

_CEU_AWAKE_YES_:
                trl->evt.id = CEU_INPUT__STACKED;
                trl->level  = level;
            }
        }
    }
}

static int ceu_bcast_exec (tceu_nstk level, tceu_stk* cur, tceu_stk* nxt)
{
    /* CLEAR: inverse execution order */
    tceu_ntrl trl0 = cur->range.trl0;
    tceu_ntrl trlF = cur->range.trlF;
    if (trl0 > trlF) {
        return 0;
    }
    if (cur->evt.id == CEU_INPUT__CLEAR) {
        tceu_ntrl tmp = trl0;
        trl0 = trlF;
        trlF = tmp;
    }

    tceu_ntrl trlK = trl0;

    //printf(">>> exec %d -> %d\n", trl0, trlF);
    while (1)
    {
        tceu_trl* trl = &cur->range.mem->_trails[trlK];

        //printf(">>> exec [%d/%p] evt=%d\n", trlK, trl, trl->evt.id);
        switch (trl->evt.id)
        {
            case CEU_INPUT__PROPAGATE_CODE: {
#if 0
                // TODO: simple optimization that could be done
                //          - do it also for POOL?
                if (occ->evt.id==CEU_INPUT__CODE_TERMINATED && occ->params==trl->evt.mem ) {
                    // dont propagate when I am terminating
                } else
#endif
                {
                    tceu_range range_ = {
                        (tceu_code_mem*)trl->evt.mem,
                        0,
                        (tceu_ntrl)(((tceu_code_mem*)trl->evt.mem)->trails_n-1)
                    };
                    tceu_stk cur_ = *cur;
                    cur_.range = range_;
                    if (ceu_bcast_exec(level, &cur_, nxt)) {
                        return 1;
                    }
                }
                break;
            }

#ifdef CEU_FEATURES_POOL
            case CEU_INPUT__PROPAGATE_POOL: {
                ceu_assert_ex(trl->evt.pak->n_traversing < 255, "bug found", CEU_TRACE_null);
                trl->evt.pak->n_traversing++;
                tceu_code_mem_dyn* v = trl->evt.pak->first.nxt;
                while (v != &trl->evt.pak->first) {
                    if (v->is_alive) {
                        tceu_range range_ = { &v->mem[0],
                                              0, (tceu_ntrl)((&v->mem[0])->trails_n-1) };
                        tceu_stk cur_ = *cur;
                        cur_.range = range_;
                        if (ceu_bcast_exec(level, &cur_, nxt)) {
                            trl->evt.pak->n_traversing--;
                            return 1;
                        }
                    }
                    v = v->nxt;
                }
                trl->evt.pak->n_traversing--;
                ceu_code_mem_dyn_gc(trl->evt.pak);
                break;
            }
#endif

            case CEU_INPUT__STACKED: {
                if (trl->evt.id==CEU_INPUT__STACKED && trl->level==level) {
                    trl->evt.id = CEU_INPUT__NONE;
//printf("STK = %d\n", trlK);
                    if (ceu_lbl(level, cur, nxt, cur->range.mem, trl->lbl, &trlK)) {
                        return 1;
                    }
//printf("<<< trlK = %d\n", trlK);
                }
                break;
            }
        }

        if (cur->evt.id == CEU_INPUT__CLEAR) {
            trl->evt.id = CEU_INPUT__NONE;
        }

        if (trlK == trlF) {
            break;
        } else if (cur->evt.id == CEU_INPUT__CLEAR) {
            trlK--; trl--;
        } else {
            trlK++; trl++;
        }
    }
    return 0;
}

static void ceu_bcast (tceu_nstk level, tceu_stk* cur)
{
    if (cur->evt.id>CEU_INPUT__PRIM && cur->evt.id<CEU_EVENT__MIN) {
        switch (cur->evt.id) {
            case CEU_INPUT__WCLOCK:
                CEU_APP.wclk_min_cmp = CEU_APP.wclk_min_set;    /* swap "cmp" to last "set" */
                CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;     /* new "set" resets to inactive */
                ceu_callback_wclock_min(CEU_WCLOCK_INACTIVE, CEU_TRACE_null);
                if (CEU_APP.wclk_min_cmp <= *((s32*)cur->params)) {
                    CEU_APP.wclk_late = *((s32*)cur->params) - CEU_APP.wclk_min_cmp;
                }
                break;
#ifdef CEU_FEATURES_ASYNC
            case CEU_INPUT__ASYNC:
                CEU_APP.async_pending = 0;
                break;
#endif
        }
        if (cur->evt.id != CEU_INPUT__WCLOCK) {
            CEU_APP.wclk_late = 0;
        }
    }

    //printf(">>> BCAST[%d]: %d\n", cur->evt.id, level);
    ceu_bcast_mark(level, cur);
    while (1) {
        tceu_stk nxt;
        nxt.is_alive = 1;
        nxt.prv = cur;
        int ret = ceu_bcast_exec(level, cur, &nxt);
        if (ret) {
            ceu_assert_sys(level < 255, "too many stack levels");
            ceu_bcast(level+1, &nxt);
            if (!cur->is_alive) {
                break;
            }
        } else {
            break;
        }
    }

    CEU_APP.stack_i -= cur->params_n;
    //printf("<<< BCAST: %d\n", level);
}

CEU_API void ceu_input (tceu_nevt id, void* params)
{
    s32 dt = ceu_callback_wclock_dt(CEU_TRACE_null);
    if (dt != CEU_WCLOCK_INACTIVE) {
        tceu_evt   evt   = {CEU_INPUT__WCLOCK, {NULL}};
        tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
        tceu_stk   cur   = { evt, range, &dt, 0, 1, NULL };
        ceu_bcast(1, &cur);
    }
    if (id != CEU_INPUT__NONE) {
        tceu_evt   evt   = {id, {NULL}};
        tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
        tceu_stk   cur   = { evt, range, params, 0, 1, NULL };
        ceu_bcast(1, &cur);
    }
}

CEU_API void ceu_start (int argc, char* argv[]) {
#ifdef CEU_FEATURES_OS
    CEU_APP.argc     = argc;
    CEU_APP.argv     = argv;
    CEU_APP.end_ok   = 0;
#endif

#ifdef CEU_FEATURES_ASYNC
    CEU_APP.async_pending = 0;
#endif

    CEU_APP.wclk_late = 0;
    CEU_APP.wclk_min_set = CEU_WCLOCK_INACTIVE;
    CEU_APP.wclk_min_cmp = CEU_WCLOCK_INACTIVE;

    CEU_APP.root._mem.up_mem   = NULL;
    CEU_APP.root._mem.depth    = 0;

#ifdef CEU_FEATURES_TRACE
    CEU_APP.root._mem.trace.up = NULL;
#endif
#ifdef CEU_FEATURES_EXCEPTION
    CEU_APP.root._mem.catches  = NULL;
#endif
#ifdef CEU_FEATURES_LUA
    CEU_APP.root._mem.lua      = NULL;
#endif

#ifdef CEU_FEATURES_THREAD
    pthread_mutex_init(&CEU_APP.threads_mutex, NULL);
    CEU_APP.threads_head = NULL;

    /* All code run atomically:
     * - the program is always locked as a whole
     * -    thread spawns will unlock => re-lock
     * - but program will still run to completion
     */
    CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
#endif

    CEU_APP.stack_i = 0;

    CEU_APP.root._mem.trails_n = CEU_TRAILS_N;
    memset(&CEU_APP.root._trails, 0, CEU_TRAILS_N*sizeof(tceu_trl));
    CEU_APP.root._trails[0].evt.id = CEU_INPUT__STACKED;
    CEU_APP.root._trails[0].level  = 1;
    CEU_APP.root._trails[0].lbl    = CEU_LABEL_ROOT;

    ceu_callback_start(CEU_TRACE_null);

    tceu_evt   evt   = {CEU_INPUT__NONE, {NULL}};
    tceu_range range = {(tceu_code_mem*)&CEU_APP.root, 0, CEU_TRAILS_N-1};
    tceu_stk   cur   = { evt, range, NULL, 0, 1, NULL };
    ceu_bcast(1, &cur);
}
CEU_API void ceu_stop (void) {
#ifdef CEU_FEATURES_THREAD
    CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
    ceu_assert_ex(ceu_threads_gc(1) == 0, "bug found", CEU_TRACE_null); /* wait all terminate/free */
#endif
    ceu_callback_stop(CEU_TRACE_null);
}

/*****************************************************************************/

CEU_API int ceu_loop (int argc, char* argv[])
{
    ceu_start(argc, argv);

#ifdef CEU_FEATURES_OS
    while (!CEU_APP.end_ok)
#else
    while (1)
#endif
    {
        ceu_callback_step(CEU_TRACE_null);
#ifdef CEU_FEATURES_THREAD
        if (CEU_APP.threads_head != NULL) {
            CEU_THREADS_MUTEX_UNLOCK(&CEU_APP.threads_mutex);
/* TODO: remove this!!! */
            CEU_THREADS_SLEEP(100); /* allow threads to do "atomic" and "terminate" */
            CEU_THREADS_MUTEX_LOCK(&CEU_APP.threads_mutex);
            ceu_threads_gc(0);
        }
#endif
#ifdef CEU_FEATURES_ASYNC
        ceu_input(CEU_INPUT__ASYNC, NULL);
#endif
    }

#ifdef CEU_FEATURES_OS
    ceu_stop();

#ifdef CEU_TESTS
    printf("_ceu_tests_bcasts_ = %d\n", _ceu_tests_bcasts_);
    printf("_ceu_tests_trails_visited_ = %d\n", _ceu_tests_trails_visited_);
    fflush(stdout);
#endif

    return CEU_APP.end_val;
#else
    return 0;
#endif
}
